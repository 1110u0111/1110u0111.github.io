<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="弱小和无知不是生存的障碍，傲慢才是。">
<meta property="og:type" content="website">
<meta property="og:title" content="Rebecca的赛博世界">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Rebecca的赛博世界">
<meta property="og:description" content="弱小和无知不是生存的障碍，傲慢才是。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Rebecca">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Rebecca的赛博世界</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rebecca的赛博世界</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Python机器学习基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 20:49:37" itemprop="dateCreated datePublished" datetime="2022-06-09T20:49:37+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-11 21:30:05" itemprop="dateModified" datetime="2022-06-11T21:30:05+08:00">2022-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="numpy-数值计算基础">NumPy 数值计算基础</h1>
<h2
id="数组对象ndarray常用属性">数组对象<code>ndarray</code>常用属性</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性名称</th>
<th style="text-align: center;">作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>dtype</code></td>
<td style="text-align: center;">返回数组元素的类型</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>shape</code></td>
<td style="text-align: center;">返回以元组(tuple)表示的数组形状</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>ndim</code></td>
<td style="text-align: center;">返回数组的维度</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>size</code></td>
<td style="text-align: center;">返回数组中元素的个数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>itemsize</code></td>
<td style="text-align: center;">返回数组中元素的内存所占字节数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>T</code></td>
<td style="text-align: center;">返回数组的转置</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>nbytes</code></td>
<td style="text-align: center;">返回数组占用的存储空间</td>
</tr>
</tbody>
</table>
<h2
id="数组对象ndarray常用方法">数组对象<code>ndarray</code>常用方法</h2>
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">方法名称</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>reshape()</code></td>
<td
style="text-align: center;">返回一个给定大小(shape)的数组的副本，原数组的大小不变</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>resize()</code></td>
<td
style="text-align: center;">返回一个给定大小(shape)的数组，原数组的大小改变</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>flatten()</code>/<code>ravel()</code></td>
<td style="text-align: center;">返回展平的数组，原数组不变</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>astype(dtype)</code></td>
<td style="text-align: center;">返回指定数据类型(dtype)的数组副本</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>sum()</code>/<code>prod()</code></td>
<td style="text-align: center;">返回所有数组元素的和/积</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>mean()</code>/<code>var()</code>/<code>std()</code></td>
<td style="text-align: center;">返回数组元素的均值/方差/标准差</td>
</tr>
<tr class="odd">
<td
style="text-align: center;"><code>max()</code>/<code>min()</code>/<code>ptp()</code>/<code>median()</code></td>
<td
style="text-align: center;">返回数组元素的最大值/最小值/取值范围/中位数</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>argmax()</code>/<code>argmin()</code></td>
<td style="text-align: center;">返回最大值/最小值的索引</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>sort()</code></td>
<td
style="text-align: center;">对数组进行排序，其中axis指定排序的轴，kind指定排序算法，默认快速排序</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>compress()</code></td>
<td style="text-align: center;">返回由满足条件元素构成的数组</td>
</tr>
</tbody>
</table>
<h2
id="数组创建函数numpy.array">数组创建函数<code>numpy.array()</code></h2>
<p><code>numpy.array()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性名称</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>.shape</code></td>
<td style="text-align: center;">数组的形状，如行数，列数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>.ndim</code></td>
<td style="text-align: center;">数组的维数</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>.size</code></td>
<td style="text-align: center;">数组中元素的数量</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>.itemsize</code></td>
<td style="text-align: center;">数组中元素的长度，按字节计</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>.nbytes</code></td>
<td style="text-align: center;">数组全部元素占用的字节数</td>
</tr>
</tbody>
</table>
<h2
id="等差数列创建函数numpy.arangenumpy.linspace">等差数列创建函数<code>numpy.arange()</code>,<code>numpy.linspace()</code></h2>
<p><code>numpy.arange()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.arange([start,] stop, [step,] dtype = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>[start,]</code></td>
<td
style="text-align: center;">接收浮点数，表示数组的起始值，可选，默认为0</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>stop</code></td>
<td
style="text-align: center;">接收浮点数，表示数组的终止值(<strong>不包含在数组之内</strong>)</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>[step,]</code></td>
<td
style="text-align: center;">接收浮点数，表示数组的步长值，可选，默认为1</td>
</tr>
</tbody>
</table>
<p>由于<code>numpy.arange()</code>函数并未指定元素个数，因此，若需要指定元素个数，则需要使用<code>numpy.linspace()</code>函数。</p>
<p>函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num = <span class="number">50</span>, endpoint = <span class="literal">True</span>, retstep = <span class="literal">False</span>, dtype = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>start</code></td>
<td style="text-align: center;">接收浮点数，表示数组的起始值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>stop</code></td>
<td style="text-align: center;">接收浮点数，表示数组的终止值</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>num</code></td>
<td
style="text-align: center;">接收整数，表示数组的元素数量，默认为50。</td>
</tr>
</tbody>
</table>
<h2
id="等比数列创建函数numpy.logspace">等比数列创建函数<code>numpy.logspace()</code></h2>
<p>函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.logspace(start, stop, num = <span class="number">50</span>, endpoint = <span class="literal">True</span>, base = <span class="number">10.0</span>, dtype = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>start</code></td>
<td
style="text-align: center;">接收浮点数，表示数组起始值的指数，指定的数组起始值为
<span class="math inline">\(\text{base}^{\text{start}}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>stop</code></td>
<td
style="text-align: center;">接收浮点数，表示数组终止值的指数，指定的数组终止值为
<span class="math inline">\(\text{base}^{\text{stop}}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>num</code></td>
<td
style="text-align: center;">接收整数，表示数组的元素数量，默认为50。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>base</code></td>
<td
style="text-align: center;">接收浮点数，以幂形式表示数组起始值、终止值的底数</td>
</tr>
</tbody>
</table>
<h2 id="特殊值数组创建函数">特殊值数组创建函数</h2>
<h3
id="数组元素值全为0的函数numpy.zeros">数组元素值全为0的函数<code>numpy.zeros()</code></h3>
<p><code>numpy.zeros()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>shape</code></td>
<td style="text-align: center;">数组的形状</td>
</tr>
</tbody>
</table>
<h3
id="对角线全为1其余为0的函数numpy.eye">对角线全为1，其余为0的函数<code>numpy.eye()</code></h3>
<p><code>numpy.eye()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.eye(N, M = <span class="literal">None</span>, k = <span class="number">0</span>, dtype = &lt;<span class="keyword">class</span><span class="string">&#x27;float&#x27;</span>&gt;, order = <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>N</code></td>
<td style="text-align: center;">接收整数，表示数组的行形状</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>M</code></td>
<td
style="text-align: center;">接收整数，表示数组的列形状，可选，默认等于<code>N</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>k</code></td>
<td
style="text-align: center;">接收整数，表示选择的对角线位置，可选，默认为0，表示选择主对角线，<br /><code>k</code>
为正值表示选择上方次对角线，<code>k</code>
为负值表示选择下方次对角线，</td>
</tr>
</tbody>
</table>
<h3
id="行列形状相同指定对角线元素值的函数numpy.diag">行列形状相同，指定对角线元素值的函数<code>numpy.diag()</code></h3>
<p><code>numpy.diag()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.diag(v,k = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>v</code></td>
<td
style="text-align: center;">接收<strong>数组</strong>，表示指定对角线上自左上方至右下方的元素值</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>k</code></td>
<td
style="text-align: center;">接收整数，表示选择的对角线位置，可选，默认为0，表示选择主对角线，<br /><code>k</code>
为正值表示选择上方次对角线，<code>k</code>
为负值表示选择下方次对角线，</td>
</tr>
</tbody>
</table>
<h3 id="数组元素值全为1的函数-numpy.ones">数组元素值全为1的函数
<code>numpy.ones()</code></h3>
<p><code>numpy.ones()</code> 的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ones(shape, dtype = <span class="literal">None</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>shape</code></td>
<td style="text-align: center;">数组的形状</td>
</tr>
</tbody>
</table>
<h3
id="随机数组创建函数-numpy.random.random-numpy.random.rand-numpy.random.randn-numpy.random.randint">随机数组创建函数
<code>numpy.random.random()</code>, <code>numpy.random.rand()</code>,
<code>numpy.random.randn()</code>,
<code>numpy.random.randint()</code></h3>
<p><code>numpy.random.random()</code> ，该方法用于创建指定元素数量的在
<span class="math inline">\([0.0,1.0]\)</span>
区间连续均匀分布的随机数组，函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.random(size = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><code>numpy.random.rand()</code> ，该方法用于创建 <span
class="math inline">\(n\)</span> 维数组，其中每一维的元素在 <span
class="math inline">\([0.0,1.0]\)</span>
区间连续均匀分布，函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.rand(d0,d1,...,dn)</span><br></pre></td></tr></table></figure>
<p><code>numpy.random.randn()</code>
，该方法用于创建标准正态分布的数组，函数格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randn(d0,d1,...,dn)</span><br></pre></td></tr></table></figure>
<p><code>numpy.random.randint()</code>
，该方法用于创建在指定范围内正态分布的整数(离散)数组，函数格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.random.randint(low, high = None, size = None, dytpe = &#x27;1&#x27;)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>low</code></td>
<td style="text-align: center;">数组指定范围 <span
class="math inline">\([low,high)\)</span> 的下限</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>high</code></td>
<td style="text-align: center;">数组指定范围 <span
class="math inline">\([low,high)\)</span>
的上限(不包括上限)，默认无。<br />当不指定 <span
class="math inline">\(high\)</span> 时，默认范围为 <span
class="math inline">\([0,low)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>size</code></td>
<td style="text-align: center;">数组形状</td>
</tr>
</tbody>
</table>
<h2 id="索引数组元素">索引数组元素</h2>
<h3 id="一维数组元素的索引方法">一维数组元素的索引方法</h3>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n]</code></td>
<td style="text-align: center;">索引数组的第 <span
class="math inline">\(n\)</span> 个元素， <span
class="math inline">\(n\)</span> 从 <span
class="math inline">\(0\)</span> 开始</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[n:m]</code></td>
<td style="text-align: center;">索引数组的第 <span
class="math inline">\(n\)</span> 到 <span
class="math inline">\(m\)</span> 的元素， 不包括第 <span
class="math inline">\(m\)</span> 个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[:m]</code></td>
<td style="text-align: center;">索引数组的第 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(m\)</span> 的元素， 不包括第 <span
class="math inline">\(m\)</span> 个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[-1]</code></td>
<td style="text-align: center;">索引数组的倒数第 <span
class="math inline">\(1\)</span> 个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n:m:k]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 个元素开始，每隔 <span
class="math inline">\(k-1\)</span> 个元素，一直到第 <span
class="math inline">\(m\)</span> 个元素之间的元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[m:n:-k]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(m\)</span> 个元素开始，每隔 <span
class="math inline">\(k-1\)</span> 个元素，一直到第 <span
class="math inline">\(n\)</span> 个元素之间的元素，<span
class="math inline">\(m &gt; n\)</span></td>
</tr>
</tbody>
</table>
<h3 id="二维数组元素的索引方法">二维数组元素的索引方法</h3>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">方法</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n,m]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 行，第 <span
class="math inline">\(m\)</span> 列的一个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[n,i:j]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 行，第 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j-1\)</span> 列的连续多个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n,:]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 行元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[i:j,:]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j-1\)</span> 行的连续整行元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[:,i:j]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j-1\)</span> 列的连续整列元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[n:m,i:j]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 到 <span
class="math inline">\(m-1\)</span> 行，第 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j-1\)</span> 列的元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n:,m:]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 到最后1行，第 <span
class="math inline">\(m\)</span> 到最后1列的元素</td>
</tr>
<tr class="even">
<td
style="text-align: center;"><code>数组名[(n1,n2,n3),(m1,m2,m3)]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n1\)</span> 行 <span
class="math inline">\(m1\)</span> 列、第 <span
class="math inline">\(n2\)</span> 行 <span
class="math inline">\(m2\)</span> 列、第 <span
class="math inline">\(n3\)</span> 行 <span
class="math inline">\(m3\)</span> 列的多个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n,(m1,m2)]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n\)</span> 行 <span
class="math inline">\(m1\)</span> 和 <span
class="math inline">\(m2\)</span> 列的多个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[(n1,n2),m]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(m\)</span> 列 <span
class="math inline">\(n1\)</span> 和 <span
class="math inline">\(n2\)</span> 行的多个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[n1:n2,(m1,m2)]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n1\)</span> 到 <span
class="math inline">\(n2-1\)</span> 行 <span
class="math inline">\(m1\)</span> 列、<span
class="math inline">\(m2\)</span> 列的多个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[(n1,n2),m1:m2]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(m1\)</span> 到 <span
class="math inline">\(m2\)</span> 列 <span
class="math inline">\(n1\)</span> 行、<span
class="math inline">\(n2\)</span> 行的多个元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>数组名[:,(m1,m2)]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(m1\)</span> 列、第 <span
class="math inline">\(m2\)</span> 列的整列元素</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>数组名[(n1,n2),:]</code></td>
<td style="text-align: center;">索引数组中第 <span
class="math inline">\(n1\)</span> 行、第 <span
class="math inline">\(n2\)</span> 行的整行元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>numpy.bool</code></td>
<td style="text-align: center;">索引 (1) 或不索引 (0) 某行/列元素</td>
</tr>
</tbody>
</table>
<h2 id="改变数组形状">改变数组形状</h2>
<h3
id="多维数组展平为一维数组-numpy.ravelnumpy.flatten">多维数组展平为一维数组
<code>numpy.ravel()</code>/<code>numpy.flatten()</code></h3>
<p><code>numpy.ravel()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ravel(a, order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>a</code></td>
<td style="text-align: center;">需要展平的数组</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>order</code></td>
<td style="text-align: center;">展平顺序，<code>'C'</code>
表示按行展平，<code>'F'</code> 表示按列展平</td>
</tr>
</tbody>
</table>
<p><code>numpy.flatten()</code>的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.ndarray.flatten(order = <span class="string">&#x27;C&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="组合数组">组合数组</h2>
<h3
id="将两个或多个行数相等的数组横向组合为一个数组numpy.hstack">将两个或多个行数相等的数组横向组合为一个数组<code>numpy.hstack()</code></h3>
<p><code>numpy.hstack()</code> 的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.hstack(tup)</span><br></pre></td></tr></table></figure>
<h3
id="将两个或多个列数相等的数组纵向组合为一个数组numpy.vstack">将两个或多个列数相等的数组纵向组合为一个数组<code>numpy.vstack()</code></h3>
<p><code>numpy.vstack()</code> 的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.vstack(tup)</span><br></pre></td></tr></table></figure>
<h3
id="可指定数组为横向组合还是列向组合numpy.concatenate">可指定数组为横向组合还是列向组合<code>numpy.concatenate()</code></h3>
<p><code>numpy.concatenate()</code> 的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.concatenate((a1,a2,...), axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3
id="将两个或多个行数相等的数组横向组合numpy.c_">将两个或多个行数相等的数组横向组合<code>numpy.c_[]</code></h3>
<p><code>numpy.c_[]</code> 的函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.c_[a1,a2,...]</span><br></pre></td></tr></table></figure>
<h2 id="分割数组">分割数组</h2>
<p><code>numpy.hspilt()</code>
将数组横向分割为2个或多个形状相同的子数组，或按照指定的分割位置进行分割，函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.hspilt(ary,indices_or_sections)</span><br></pre></td></tr></table></figure>
<p><code>numpy.vspilt()</code>
将数组纵向分割为2个或多个形状相同的子数组，或按照指定的分割位置进行分割，函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.vspilt(ary,indices_or_sections)</span><br></pre></td></tr></table></figure>
<p><code>numpy.spilt()</code>
将数组沿指定方向分割为2个或多个形状相同的子数组，或按照指定的分割位置进行分割，函数格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.spilt(ary,indices_or_sections,axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">参数</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>ary</code></td>
<td style="text-align: center;">接收要分割的数组</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>indices_or_sections</code></td>
<td
style="text-align: center;">为整数时，表示分割为子数组的数量；<br />为序列
<span class="math inline">\([n1,n2,...]\)</span>
时，表示要分割的行(列)位置</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>axis</code></td>
<td
style="text-align: center;">表示分割方向，为0时表示纵向分割，为1时表示横向分割</td>
</tr>
</tbody>
</table>
<h2 id="数组的运算">数组的运算</h2>
<p>略。</p>
<h1 id="matplotlib可视化基础">Matplotlib可视化基础</h1>
<h2 id="绘图元素">绘图元素</h2>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">基本元素</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">x轴和y轴</td>
<td style="text-align: center;">水平和垂直的轴线</td>
</tr>
<tr class="even">
<td style="text-align: center;">x轴和y轴的刻度</td>
<td
style="text-align: center;">刻度标示坐标轴的分隔，包括最小刻度和最大刻度</td>
</tr>
<tr class="odd">
<td style="text-align: center;">x轴和y轴的刻度标签</td>
<td style="text-align: center;">特定坐标轴的值</td>
</tr>
<tr class="even">
<td style="text-align: center;">绘图区域</td>
<td style="text-align: center;">实际绘图的区域</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hold属性</td>
<td
style="text-align: center;">默认为True，表示允许在一幅图中绘制多条曲线，如果为False，则每一个plot都会覆盖前面的plot</td>
</tr>
<tr class="even">
<td style="text-align: center;">grid方法</td>
<td style="text-align: center;">为图添加网格线</td>
</tr>
<tr class="odd">
<td style="text-align: center;">xlim和ylim方法</td>
<td style="text-align: center;">设置坐标轴范围</td>
</tr>
<tr class="even">
<td style="text-align: center;">legend方法</td>
<td style="text-align: center;">设置图例</td>
</tr>
</tbody>
</table>
<h2 id="散点图">散点图</h2>
<p>绘制例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>)) <span class="comment">#设置画布</span></span><br><span class="line">plt.scatter(x,y1,marker=<span class="string">&#x27;o&#x27;</span>) <span class="comment">#绘制散点图</span></span><br><span class="line">plt.scatter(x,y2,marker=<span class="string">&#x27;*&#x27;</span>) <span class="comment">#绘制散点图</span></span><br><span class="line">plt.scatter(x,y3,marker=<span class="string">&#x27;^&#x27;</span>) <span class="comment">#绘制散点图</span></span><br><span class="line">plt.title(<span class="string">&#x27;散点图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.legend([<span class="string">&#x27;数据集y1&#x27;</span>,<span class="string">&#x27;数据集y2&#x27;</span>,<span class="string">&#x27;数据集y3&#x27;</span>]) <span class="comment">#添加图例</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;scatter.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatter.jpg" class="" title="scatter">
<h2 id="折线图和点线图">折线图和点线图</h2>
<p>绘制例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment">#绘制折线图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.plot(x,y1,color=<span class="string">&#x27;r&#x27;</span>,linestyle=<span class="string">&#x27;--&#x27;</span>) <span class="comment">#&#x27;r&#x27;表示红色</span></span><br><span class="line">plt.plot(x,y2,color=<span class="string">&#x27;g&#x27;</span>,linestyle=<span class="string">&#x27;-&#x27;</span>) <span class="comment">#&#x27;g&#x27;表示绿色</span></span><br><span class="line">plt.plot(x,y3,color=<span class="string">&#x27;b&#x27;</span>,linestyle=<span class="string">&#x27;-.&#x27;</span>) <span class="comment">#&#x27;b&#x27;表示蓝色</span></span><br><span class="line">plt.title(<span class="string">&#x27;折线图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.legend([<span class="string">&#x27;曲线y1&#x27;</span>,<span class="string">&#x27;曲线y2&#x27;</span>,<span class="string">&#x27;曲线y3&#x27;</span>]) <span class="comment">#添加图例</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;plot.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/plot.jpg" class="" title="plot">
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制点线图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.plot(x,y1,color=<span class="string">&#x27;r&#x27;</span>,linestyle=<span class="string">&#x27;--&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.plot(x,y2,color=<span class="string">&#x27;g&#x27;</span>,linestyle=<span class="string">&#x27;-&#x27;</span>,marker=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.plot(x,y3,color=<span class="string">&#x27;b&#x27;</span>,linestyle=<span class="string">&#x27;-.&#x27;</span>,marker=<span class="string">&#x27;^&#x27;</span>) </span><br><span class="line">plt.title(<span class="string">&#x27;点线图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.legend([<span class="string">&#x27;曲线y1&#x27;</span>,<span class="string">&#x27;曲线y2&#x27;</span>,<span class="string">&#x27;曲线y3&#x27;</span>]) <span class="comment">#添加图例</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.savefig(path + <span class="string">&#x27;plot1.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/plot1.jpg" class="" title="plot1">
<h2 id="柱状图">柱状图</h2>
<h3 id="绘制数据系列的柱状图">绘制数据系列的柱状图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment">#绘制柱状图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.bar(x,y1,width=<span class="number">0.2</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;bar.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/bar.jpg" class="" title="bar">
<h3 id="绘制数据系列和的柱状图">绘制数据系列和的柱状图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制三个数据系列各自的和的柱状图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.bar([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[np.<span class="built_in">sum</span>(y1),np.<span class="built_in">sum</span>(y2),np.<span class="built_in">sum</span>(y3)],width=<span class="number">0.5</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">labels=[<span class="string">&#x27;y1的和&#x27;</span>,<span class="string">&#x27;y2的和&#x27;</span>,<span class="string">&#x27;y3的和&#x27;</span>]</span><br><span class="line">plt.xlabel(<span class="string">&#x27;数据系列y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;数据系列y的和&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">3</span>),labels) <span class="comment">#横轴刻度与标签对准</span></span><br><span class="line">plt.savefig(path + <span class="string">&#x27;bar1.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/bar1.jpg" class="" title="bar1">
<h3 id="绘制堆叠柱状图">绘制堆叠柱状图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制堆叠柱状图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.bar(x,y1,width=<span class="number">0.2</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.bar(x,y2,width=<span class="number">0.2</span>,bottom=y1)<span class="comment">#绘制柱状图，堆叠到y1上方</span></span><br><span class="line">plt.title(<span class="string">&#x27;堆叠柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.legend([<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>])</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;bar2.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/bar2.jpg" class="" title="bar2">
<h3 id="绘制水平柱状图">绘制水平柱状图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制水平柱状图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.barh(x,width=y1,height=<span class="number">0.2</span>)<span class="comment">#绘制水平柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;水平柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.savefig(path + <span class="string">&#x27;bar3.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/bar3.jpg" class="" title="bar3">
<h3 id="绘制水平堆叠柱状图">绘制水平堆叠柱状图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制水平堆叠柱状图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.barh(x,width=y1,height=<span class="number">0.2</span>)<span class="comment">#绘制水平柱状图</span></span><br><span class="line">plt.barh(x,width=y2,height=<span class="number">0.2</span>,left=y1)<span class="comment">#绘制水平柱状图，堆叠到y1右侧</span></span><br><span class="line">plt.barh(x,width=y3,height=<span class="number">0.2</span>,left=y1+y2)<span class="comment">#绘制水平柱状图，堆叠到y1+y2右侧</span></span><br><span class="line">plt.title(<span class="string">&#x27;水平堆叠柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.legend([<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>,<span class="string">&#x27;y3&#x27;</span>])</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;bar4.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/bar4.jpg" class="" title="bar4">
<h2 id="饼图">饼图</h2>
<h3 id="绘制饼图">绘制饼图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment">#绘制饼图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">labels=[<span class="string">&#x27;y1的和&#x27;</span>,<span class="string">&#x27;y2的和&#x27;</span>,<span class="string">&#x27;y3的和&#x27;</span>] <span class="comment">#设置标签</span></span><br><span class="line">plt.pie([np.<span class="built_in">sum</span>(y1),np.<span class="built_in">sum</span>(y2),np.<span class="built_in">sum</span>(y3)],labels=labels,autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;饼图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;pie.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/pie.jpg" class="" title="pie">
<h3 id="绘制分离饼图">绘制分离饼图</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制分离饼图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">labels=[<span class="string">&#x27;y1的和&#x27;</span>,<span class="string">&#x27;y2的和&#x27;</span>,<span class="string">&#x27;y3的和&#x27;</span>] <span class="comment">#设置标签</span></span><br><span class="line">plt.pie([np.<span class="built_in">sum</span>(y1),np.<span class="built_in">sum</span>(y2),np.<span class="built_in">sum</span>(y3)],</span><br><span class="line">        explode=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>),labels=labels,</span><br><span class="line">        autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>,shadow=<span class="literal">True</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;分离饼图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.savefig(path + <span class="string">&#x27;pie1.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/pie1.jpg" class="" title="pie1">
<h2 id="箱线图">箱线图</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment">#绘制箱线图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">labels=[<span class="string">&#x27;数据系列y1&#x27;</span>,<span class="string">&#x27;数据系列y2&#x27;</span>,<span class="string">&#x27;数据系列y3&#x27;</span>] <span class="comment">#设置标签</span></span><br><span class="line">plt.boxplot([y1,y2,y3],notch = <span class="literal">True</span>, labels = labels, meanline = <span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;箱线图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;数据系列y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;数据系列y的值&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;box.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/box.jpg" class="" title="box">
<h2 id="直方图">直方图</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x_norm1 = np.random.randn(<span class="number">1000</span>) <span class="comment">#生成有1000个标准正态分布元素的数组</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment">#绘制直方图</span></span><br><span class="line">plt.figure(figsize = (<span class="number">6</span>,<span class="number">4</span>))<span class="comment">#设置画布</span></span><br><span class="line">plt.hist(x_norm1,bins=<span class="number">50</span>) <span class="comment">#绘制直方图，分箱数为50</span></span><br><span class="line">plt.title(<span class="string">&#x27;直方图（频数）&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;hist.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/hist.jpg" class="" title="hist">
<h2 id="子图">子图</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入Numpy模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment">#导入matplotlib.pyplot库</span></span><br><span class="line"><span class="comment">#产生数据</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">30</span>) <span class="comment">#产生0至10之间的30个元素的等差数列</span></span><br><span class="line">noise = np.random.randn(<span class="number">30</span>) <span class="comment">#产生30个标准正态分布的元素</span></span><br><span class="line">y1 = x**<span class="number">2</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列1（x**2为x的平方）</span></span><br><span class="line">y2 = x**<span class="number">1</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列2</span></span><br><span class="line">y3 = x**<span class="number">1.5</span>+<span class="number">2</span>*noise <span class="comment">#产生叠加噪声的数据系列3</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span> <span class="comment">#设置字体为SimHei以显示中文</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>,size = <span class="number">14</span>) <span class="comment">#设置图中字号大小</span></span><br><span class="line"><span class="comment"># 绘制子图</span></span><br><span class="line">p = plt.figure(figsize = (<span class="number">12</span>,<span class="number">12</span>)) <span class="comment">#设置画布大小</span></span><br><span class="line"><span class="comment">#子图1，点线图</span></span><br><span class="line">ax1 = p.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(x,y1,color=<span class="string">&#x27;r&#x27;</span>,linestyle=<span class="string">&#x27;--&#x27;</span>) <span class="comment">#&#x27;r&#x27;表示红色</span></span><br><span class="line">plt.plot(x,y2,color=<span class="string">&#x27;g&#x27;</span>,linestyle=<span class="string">&#x27;-&#x27;</span>) <span class="comment">#&#x27;g&#x27;表示绿色</span></span><br><span class="line">plt.plot(x,y3,color=<span class="string">&#x27;b&#x27;</span>,linestyle=<span class="string">&#x27;-.&#x27;</span>) <span class="comment">#&#x27;b&#x27;表示蓝色</span></span><br><span class="line">plt.title(<span class="string">&#x27;折线图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.legend([<span class="string">&#x27;曲线y1&#x27;</span>,<span class="string">&#x27;曲线y2&#x27;</span>,<span class="string">&#x27;曲线y3&#x27;</span>]) <span class="comment">#添加图例</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子图2，柱状图</span></span><br><span class="line">ax1 = p.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.bar([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],[np.<span class="built_in">sum</span>(y1),np.<span class="built_in">sum</span>(y2),np.<span class="built_in">sum</span>(y3)],width=<span class="number">0.5</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;柱状图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">labels=[<span class="string">&#x27;y1的和&#x27;</span>,<span class="string">&#x27;y2的和&#x27;</span>,<span class="string">&#x27;y3的和&#x27;</span>]</span><br><span class="line">plt.xlabel(<span class="string">&#x27;数据系列y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;数据系列y的和&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="number">3</span>),labels) <span class="comment">#横轴刻度与标签对准</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子图3：饼图</span></span><br><span class="line">ax1 = p.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">labels=[<span class="string">&#x27;y1的和&#x27;</span>,<span class="string">&#x27;y2的和&#x27;</span>,<span class="string">&#x27;y3的和&#x27;</span>] <span class="comment">#设置标签</span></span><br><span class="line">plt.pie([np.<span class="built_in">sum</span>(y1),np.<span class="built_in">sum</span>(y2),np.<span class="built_in">sum</span>(y3)],labels=labels,autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>)<span class="comment">#绘制柱状图</span></span><br><span class="line">plt.title(<span class="string">&#x27;饼图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#子图4：箱线图</span></span><br><span class="line">ax1 = p.add_subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">labels=[<span class="string">&#x27;数据系列y1&#x27;</span>,<span class="string">&#x27;数据系列y2&#x27;</span>,<span class="string">&#x27;数据系列y3&#x27;</span>] <span class="comment">#设置标签</span></span><br><span class="line">plt.boxplot([y1,y2,y3],notch = <span class="literal">True</span>, labels = labels, meanline = <span class="literal">True</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;箱线图&#x27;</span>) <span class="comment">#添加标题</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;数据系列y&#x27;</span>) <span class="comment">#添加横轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;数据系列y的值&#x27;</span>) <span class="comment">#添加纵轴标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#导入os库</span></span><br><span class="line"><span class="comment">#创建或访问一个文件夹</span></span><br><span class="line">path = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">    os.makedirs(path)</span><br><span class="line">plt.savefig(path + <span class="string">&#x27;4subgraph.jpg&#x27;</span>)<span class="comment">#保存图片</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/4subgraph.jpg" class="" title="4subgraph">
<h1 id="seaborn统计数据可视化">Seaborn统计数据可视化</h1>
<h2 id="特征关系可视化">特征关系可视化</h2>
<h3 id="绘制散点图">绘制散点图</h3>
<ul>
<li><p>产生数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns <span class="comment">#导入Seaborn模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生2个特征3个类别的数据集</span></span><br><span class="line">num0 = <span class="number">100</span> <span class="comment">#设置类0、2的样本数量</span></span><br><span class="line">num1 = <span class="number">150</span> <span class="comment">#设置类1的样本数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#产生特征1</span></span><br><span class="line">f11 = np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类0特征1</span></span><br><span class="line">f12 = <span class="number">2</span> + np.random.randn(num1).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类1特征1</span></span><br><span class="line">f13 = <span class="number">3</span>*f11 + <span class="number">0.2</span>*np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类2特征1</span></span><br><span class="line"><span class="comment">#产生特征2</span></span><br><span class="line">f21 = np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类0特征2</span></span><br><span class="line">f22 = <span class="number">2</span> + np.random.randn(num1).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类1特征2</span></span><br><span class="line">f23 = <span class="number">3</span>*f21 + <span class="number">0.2</span>*np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类2特征2</span></span><br><span class="line"><span class="comment">#产生类标签</span></span><br><span class="line">c0 = <span class="number">0</span> * np.ones((num0,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num0行1列，值全为0</span></span><br><span class="line">c1 = <span class="number">1</span> * np.ones((num1,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num1行1列，值全为1</span></span><br><span class="line">c2 = <span class="number">2</span> * np.ones((num0,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num1行1列，值全为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成以f1，f2为特征，c为类标签的数据集</span></span><br><span class="line"><span class="comment">#先将f11，f12，f13纵向堆叠，f21，f22，f23纵向堆叠，c0，c1，c2纵向堆叠</span></span><br><span class="line"><span class="comment">#再将3个堆叠结果横向堆叠，产生的带有类标签的数据集形式为：</span></span><br><span class="line"><span class="comment">#f1 f2 c</span></span><br><span class="line">data_set = np.hstack((np.vstack((f11,f12,f13)),</span><br><span class="line">                     np.vstack((f21,f22,f23)),</span><br><span class="line">                     np.vstack((c0,c1,c2))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data_set的形状为：&#x27;</span>,data_set.shape)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_set的形状为： (<span class="number">350</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>以索引为纵坐标，绘制全部特征、类标签的散点图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将data_set转换为DataFrame，并为各列添加名称</span></span><br><span class="line">df_data = pd.DataFrame(data_set, columns=[<span class="string">&quot;f1&quot;</span>,<span class="string">&quot;f2&quot;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment">#以索引为纵坐标，绘制全部特征、类标签的散点图</span></span><br><span class="line">ax = sns.scatterplot(data=df_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line">filepath = <span class="string">&#x27;D:\\Blog\\source\\_posts\\Python机器学习基础\\&#x27;</span></span><br><span class="line">fig_name = <span class="string">&#x27;scatterplot.png&#x27;</span></span><br><span class="line"><span class="comment"># fig_path为想要存入的文件夹或地址</span></span><br><span class="line">fig_path = filepath + <span class="string">&#x27;/&#x27;</span> + fig_name</span><br><span class="line">scatter_fig = ax.get_figure()</span><br><span class="line">scatter_fig.savefig(fig_path, dpi = <span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot.png" class="" title="scatterplot"></li>
<li><p>绘制两个指定特征的散点图</p>
<ul>
<li><p>绘制两个指定特征的散点图 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制两个指定特征的散点图</span></span><br><span class="line">ax = sns.scatterplot(x = <span class="string">&quot;f1&quot;</span>,y = <span class="string">&quot;f2&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot1.png" class="" title="scatterplot1"></li>
<li><p>另一种方法 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绘制两个指定特征的散点图</span></span><br><span class="line">ax = sns.scatterplot(x = df_data.iloc[:,<span class="number">0</span>],y = <span class="string">&quot;f2&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot2.png" class="" title="scatterplot2"></li>
<li><p>对(x,y)按hue进行分组可视化，按颜色分组显示 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对(x,y)按hue进行分组可视化，按颜色分组显示</span></span><br><span class="line">ax = sns.scatterplot(x = <span class="string">&quot;f1&quot;</span>,y = <span class="string">&quot;f2&quot;</span>,hue = <span class="string">&quot;c&quot;</span>, legend = <span class="string">&#x27;full&#x27;</span>, data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot3.png" class="" title="scatterplot3"></li>
<li><p>对(x,y)按hue进行分组可视化，按颜色、大小分组显示
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对(x,y)按hue进行分组可视化，按颜色、大小分组显示</span></span><br><span class="line">ax = sns.scatterplot(x = <span class="string">&quot;f1&quot;</span>,y = <span class="string">&quot;f2&quot;</span>,hue = <span class="string">&quot;c&quot;</span>, size = <span class="string">&#x27;c&#x27;</span>, data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot4.png" class="" title="scatterplot4"></li>
<li><p>对(x,y)按hue进行分组可视化，按颜色、大小分组显示
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对(x,y)按hue进行分组可视化，按颜色、大小分组显示</span></span><br><span class="line">ax = sns.scatterplot(x = <span class="string">&quot;f1&quot;</span>,y = <span class="string">&quot;f2&quot;</span>,hue = <span class="string">&quot;c&quot;</span>, size = <span class="string">&#x27;c&#x27;</span>, legend = <span class="string">&#x27;full&#x27;</span>, data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot5.png" class="" title="scatterplot5"></li>
<li><p>对(x,y)按hue进行分组可视化，按颜色、大小分组显示
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对(x,y)按hue进行分组可视化，按颜色、大小分组显示</span></span><br><span class="line">ax = sns.scatterplot(x = <span class="string">&quot;f1&quot;</span>,y = <span class="string">&quot;f2&quot;</span>,hue = <span class="string">&quot;c&quot;</span>, size = <span class="string">&#x27;c&#x27;</span>, </span><br><span class="line">                     sizes = (<span class="number">10</span>,<span class="number">150</span>), legend = <span class="string">&#x27;full&#x27;</span>, data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图如下：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/scatterplot6.png" class="" title="scatterplot6"></li>
</ul></li>
</ul>
<h2 id="特征分类别可视化">特征分类别可视化</h2>
<h3 id="catplot函数">catplot()函数</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">x</td>
<td
style="text-align: center;">接收data的特征名，表示要可视化的特征，可选</td>
</tr>
<tr class="even">
<td style="text-align: center;">y</td>
<td
style="text-align: center;">接收data的特征名，表示要可视化的特征，可选</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hue</td>
<td
style="text-align: center;">接收data的特征名，表示要分组的特征，可选</td>
</tr>
<tr class="even">
<td style="text-align: center;">data</td>
<td style="text-align: center;">接收DataFrame对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">kind</td>
<td
style="text-align: center;">接收字符串，表示绘制的图像类型，可以为"point""bar""strip""swarm""box""violin""boxen"</td>
</tr>
<tr class="even">
<td style="text-align: center;">row</td>
<td
style="text-align: center;">接收字符串，表示按列绘制子图所按照的data特征名</td>
</tr>
<tr class="odd">
<td style="text-align: center;">col</td>
<td
style="text-align: center;">接收字符串，表示按行绘制子图所依照的data特征名</td>
</tr>
</tbody>
</table>
<ul>
<li><p>产生数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns <span class="comment">#导入Seaborn模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#产生2个特征3个类别的数据集</span></span><br><span class="line">num0 = <span class="number">100</span> <span class="comment">#设置类0、2的样本数量</span></span><br><span class="line">num1 = <span class="number">150</span> <span class="comment">#设置类1的样本数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#产生特征1</span></span><br><span class="line">f11 = np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类0特征1</span></span><br><span class="line">f12 = <span class="number">2</span> + np.random.randn(num1).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类1特征1</span></span><br><span class="line">f13 = <span class="number">3</span>*f11 + <span class="number">0.2</span>*np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类2特征1</span></span><br><span class="line"><span class="comment">#产生特征2</span></span><br><span class="line">f21 = np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类0特征2</span></span><br><span class="line">f22 = <span class="number">2</span> + np.random.randn(num1).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类1特征2</span></span><br><span class="line">f23 = <span class="number">3</span>*f21 + <span class="number">0.2</span>*np.random.randn(num0).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#类2特征2</span></span><br><span class="line"><span class="comment">#产生类标签</span></span><br><span class="line">c0 = <span class="number">0</span> * np.ones((num0,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num0行1列，值全为0</span></span><br><span class="line">c1 = <span class="number">1</span> * np.ones((num1,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num1行1列，值全为1</span></span><br><span class="line">c2 = <span class="number">2</span> * np.ones((num0,<span class="number">1</span>)).reshape(-<span class="number">1</span>,<span class="number">1</span>) <span class="comment">#num1行1列，值全为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#生成以f1，f2为特征，c为类标签的数据集</span></span><br><span class="line"><span class="comment">#先将f11，f12，f13纵向堆叠，f21，f22，f23纵向堆叠，c0，c1，c2纵向堆叠</span></span><br><span class="line"><span class="comment">#再将3个堆叠结果横向堆叠，产生的带有类标签的数据集形式为：</span></span><br><span class="line"><span class="comment">#f1 f2 c</span></span><br><span class="line">data_set = np.hstack((np.vstack((f11,f12,f13)),</span><br><span class="line">                     np.vstack((f21,f22,f23)),</span><br><span class="line">                     np.vstack((c0,c1,c2))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;data_set的形状为：&#x27;</span>,data_set.shape)</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_set的形状为： (<span class="number">350</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>绘制特征散点图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将data_set转换为DataFrame，并为各列添加名称</span></span><br><span class="line">df_data = pd.DataFrame(data_set, columns=[<span class="string">&quot;f1&quot;</span>,<span class="string">&quot;f2&quot;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment">#以索引为纵坐标，绘制全部特征、类标签的散点图</span></span><br><span class="line">ax = sns.catplot(data=df_data)</span><br></pre></td></tr></table></figure>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot.png" class="" title="catplot"></li>
<li><p>按c的值分类别绘制f2的散点图</p>
<ul>
<li><p>按c的值分类别绘制f2的散点图 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#按c的值分类别绘制f2的散点图</span></span><br><span class="line">ax = sns.catplot(x=<span class="string">&quot;c&quot;</span>, y=<span class="string">&quot;f2&quot;</span>, hue=<span class="string">&quot;c&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot1.png" class="" title="catplot1"></li>
<li><p>对类别特征添加核密度估计 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对类别特征添加核密度估计</span></span><br><span class="line">ax = sns.catplot(x=<span class="string">&quot;c&quot;</span>, y=<span class="string">&quot;f2&quot;</span>, hue=<span class="string">&quot;c&quot;</span>,kind=<span class="string">&quot;violin&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot2.png" class="" title="catplot2"></li>
<li><p>对类别特征添加核密度估计 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对类别特征添加核密度估计</span></span><br><span class="line">ax = sns.catplot(x=<span class="string">&quot;c&quot;</span>, y=<span class="string">&quot;f2&quot;</span>, hue=<span class="string">&quot;c&quot;</span>,kind=<span class="string">&quot;box&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot3.png" class="" title="catplot3"></li>
</ul></li>
<li><p>将特征按行（列）分开绘制</p>
<ul>
<li><p>按行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将特征按col（行）分开绘制</span></span><br><span class="line">ax = sns.catplot(y=<span class="string">&quot;f1&quot;</span>, hue=<span class="string">&quot;c&quot;</span>,col=<span class="string">&quot;c&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot4.png" class="" title="catplot4"></li>
<li><p>按列 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将特征按row（列）分开绘制</span></span><br><span class="line">ax = sns.catplot(y=<span class="string">&quot;f1&quot;</span>, hue=<span class="string">&quot;c&quot;</span>,row=<span class="string">&quot;c&quot;</span>,data=df_data)</span><br></pre></td></tr></table></figure></p>
<p>显示的图为：</p>
<img src="/2022/06/09/Python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/catplot5.png" class="" title="catplot5"></li>
</ul></li>
</ul>
<h3 id="stripplot方法">stripplot()方法</h3>
<p>stripplot()方法的常用参数：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">属性</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">x</td>
<td
style="text-align: center;">接收data的特征名或数组，表示要可视化的特征，可选</td>
</tr>
<tr class="even">
<td style="text-align: center;">y</td>
<td
style="text-align: center;">接收data的特征名或数组，表示要可视化的特征，可选</td>
</tr>
<tr class="odd">
<td style="text-align: center;">hue</td>
<td
style="text-align: center;">接收data的特征名或数组，表示要分组的特征，可选</td>
</tr>
<tr class="even">
<td style="text-align: center;">data</td>
<td style="text-align: center;">接收DataFrame对象</td>
</tr>
<tr class="odd">
<td style="text-align: center;">jitter</td>
<td style="text-align: center;">接收浮点数或True或1，表示条带的宽度</td>
</tr>
<tr class="even">
<td style="text-align: center;">orient</td>
<td style="text-align: center;">接收字符'v''h'，表示纵向或横向绘制</td>
</tr>
</tbody>
</table>
<h3 id="swarmplot方法">swarmplot()方法</h3>
<p>swarmplot()方法的常用参数：</p>
<h3 id="violinplot方法">violinplot()方法</h3>
<h3 id="boxenplot方法">boxenplot()方法</h3>
<h3 id="countplot方法">countplot()方法</h3>
<h2 id="特征分布可视化">特征分布可视化</h2>
<h3 id="distplot方法">distplot()方法</h3>
<h3 id="jointplot方法">jointplot()方法</h3>
<h3 id="kdeplot方法">kdeplot()方法</h3>
<h3 id="pairplot方法">pairplot()方法</h3>
<h3 id="plot.density方法">plot.density()方法</h3>
<h2 id="矩阵可视化">矩阵可视化</h2>
<h3 id="heatmap方法">heatmap()方法</h3>
<h3 id="clustermap方法">clustermap()方法</h3>
<h1 id="访问数据文件">访问数据文件</h1>
<h2 id="numpy访问数据文件">NumPy访问数据文件</h2>
<h2 id="pandas访问文本文件">Pandas访问文本文件</h2>
<h2 id="pandas访问excel文件">Pandas访问Excel文件</h2>
<h1 id="pandas-dataframe操作">Pandas DataFrame操作</h1>
<h2 id="dataframe对象及其属性">DataFrame对象及其属性</h2>
<h2 id="使用字典方式访问dataframe">使用字典方式访问DataFrame</h2>
<h2 id="使用属性方式访问dataframe">使用属性方式访问DataFrame</h2>
<h2 id="dataframe访问行的特殊方法">DataFrame访问行的特殊方法</h2>
<h2
id="使用dataframe.locdataframe.iloc对dataframe进行切片">使用DataFrame.loc[],DataFrame.iloc[]对DataFrame进行切片</h2>
<h2 id="更改dataframe中的数据">更改DataFrame中的数据</h2>
<h1
id="综合实例iris数据集特征特征间关系及分类别分析">综合实例——Iris数据集特征、特征间关系及分类别分析</h1>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">机器学习之概率图模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-06 11:15:12" itemprop="dateCreated datePublished" datetime="2022-06-06T11:15:12+08:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-09 09:57:13" itemprop="dateModified" datetime="2022-06-09T09:57:13+08:00">2022-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概率图模型">概率图模型</h1>
<h2 id="隐马尔可夫模型">隐马尔可夫模型</h2>
<h3 id="定义">定义</h3>
<ol type="1">
<li>概率模型(Probabilistic
model)：概率模型提供了一种描述框架，将学习任务归结于<strong>计算变量的概率分布</strong>。</li>
<li>推断(Inference)：在概率模型中，利用已知变量推测出未知变量的分布称为“推断”(Inference)，其核心是如何基于可观测变量推测出未知变量的<strong>条件分布</strong>。具体来说，假定所关心的变量集合为
<span class="math inline">\(Y\)</span>,可观测变量集合为 <span
class="math inline">\(O\)</span> ，其他变量的集合为 <span
class="math inline">\(R\)</span>， “生成式”模型考虑联合概率分布 <span
class="math inline">\(P(Y,R,O)\)</span>，判别式模型考虑条件分布 <span
class="math inline">\(P(Y,R|O)\)</span> 。给定一组观测值，推断就是要由
<span class="math inline">\(P(Y,R,O)\)</span> 和 <span
class="math inline">\(P(Y,R|O)\)</span> 得到条件分布 <span
class="math inline">\(P(Y|O)\)</span> 。</li>
</ol>
<h3 id="概率图模型-1">概率图模型</h3>
<p>概率图模型(Probabilistic graphical
model)是一类以图来表达变量相关关系的概率模型，其中</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">图</th>
<th style="text-align: center;">表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">结点</td>
<td style="text-align: center;">一个或一组随机变量</td>
</tr>
<tr class="even">
<td style="text-align: center;">结点之间的边</td>
<td style="text-align: center;">变量间的概率相关关系</td>
</tr>
</tbody>
</table>
<p>概率图模型可以大致分为两类：</p>
<ol type="1">
<li>使用有向无环图来表示变量间的依赖关系，称为有向无环图或贝叶斯网(Bayesian
network)。若变量之间存在显式的因果关系，则通常使用贝叶斯网。</li>
<li>使用无向图来表示变量间的依赖关系，称为无向图模型或马尔可夫网(Markov
network)。若变量间存在相关关系，但难以获得显式的因果关系，则通常使用马尔可夫网。</li>
</ol>
<h3 id="隐马尔可夫模型hidden-markov-model-hmm">隐马尔可夫模型(Hidden
Markov Model, HMM)</h3>
<p><strong>隐马尔可夫模型</strong>(Hidden Markov Model,
HMM)是结构最简单的<strong>动态贝叶斯网</strong>(Dynamic Bayesian
network)。</p>
<img src="/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/image-20220606230423648.png" class="" title="image-20220606230423648">
<p>在隐马尔可夫模型中，变量可以分为两组：</p>
<ul>
<li><strong>状态变量 <span class="math inline">\(\lbrace y_1,\cdots,y_n
\rbrace\)</span></strong> ，其中 <span class="math inline">\(y_i \in
\mathcal{Y}\)</span> 表示第 <span class="math inline">\(i\)</span>
时刻的系统状态。通常假定状态变量是<strong>隐藏的，不可观测的</strong>，因此，状态变量也称为<strong>隐变量(Hidden
variable)</strong>。</li>
<li><strong>观测变量 <span class="math inline">\(\lbrace x_1,\cdots,x_n
\rbrace\)</span></strong> ，其中 <span class="math inline">\(x_i \in
\mathcal{X}\)</span> 表示第 <span class="math inline">\(i\)</span>
时刻的观测值。</li>
</ul>
<p>图1中的箭头表示了变量间的依赖关系。</p>
<ul>
<li>在任一时刻，观测变量的取值<strong>仅</strong>依赖于状态变量，即
<span class="math inline">\(x_t\)</span> 由 <span
class="math inline">\(y_t\)</span>
确定，与其他状态变量以及观测变量无关。</li>
<li><span class="math inline">\(t\)</span> 时刻的状态 <span
class="math inline">\(y_t\)</span> 仅依赖于 <span
class="math inline">\(t-1\)</span> 时刻的状态 <span
class="math inline">\(y_{t-1}\)</span> ，与此前的 <span
class="math inline">\(t-2\)</span> 个状态无关。</li>
</ul>
<p>基于这种依赖关系，所有变量的联合概率分布为 <span
class="math display">\[
P(x_1,y_1,\cdots x_n,y_n)=P(y_1)P(x_1|y_1)
\prod_{i=2}^nP(y_i|y_{i-1})P(x_i|y_i)
\]</span>
除了结构信息，我们要确定一个隐马尔可夫模型还需要以下三个参数：</p>
<ol type="1">
<li><p><strong>状态转移概率</strong>。状态转移概率是模型在各个状态之间转换的概率，通常记为矩阵
<span class="math inline">\(A=[a_{ij}]_{N\times N}\)</span>。其中，
<span class="math display">\[
a_{ij}=P(y_{t+1}=s_j|y_t=s_i),1\le i,j \le N
\]</span> 表示在任意时刻 <span class="math inline">\(t\)</span>
，若状态为 <span class="math inline">\(s_i\)</span> ，则在下一时刻状态为
<span class="math inline">\(s_j\)</span> 的概率。</p></li>
<li><p><strong>输出观测概率</strong>。输出观测概率是模型根据当前状态获得各个观测值的概率，通常记为矩阵
<span class="math inline">\(B=[b_{ij}]_{N \times M}\)</span> 。其中，
<span class="math display">\[
b_{ij}=P(s_t=o_j|y_t=s_i),1 \le i \le N,1 \le j \le M
\]</span> 表示在任意时刻 <span class="math inline">\(t\)</span>
，若状态为 <span class="math inline">\(s_i\)</span> ，则观测值 <span
class="math inline">\(o_j\)</span> 被获取的概率。</p></li>
<li><p><strong>初始状态概率</strong>。初始状态概率是初始时刻各状态出现的概率，通常记为
<span class="math inline">\(\pi = (\pi_1,\cdots,\pi_N)\)</span> ，其中
<span class="math display">\[
\pi_i = P(y_1=s_i),1 \le i \le N
\]</span> 表示模型的初始状态为 <span class="math inline">\(s_i\)</span>
的概率。</p></li>
</ol>
<p>通过指定状态空间 <span class="math inline">\(\mathcal{Y}\)</span>
、观测空间 <span class="math inline">\(\mathcal{X}\)</span>
和上述三组参数，就能确定一个隐马尔可夫模型。</p>
<p>在实际应用中，人们常常关注3个基本问题：</p>
<ol type="1">
<li>如何评估模型和观测序列之间的匹配程度？</li>
<li>如何根据观测序列推断出隐藏的模型状态？</li>
<li>如何训练模型使其能最好的描述观测数据？</li>
</ol>
<h2 id="马尔可夫随机场">马尔可夫随机场</h2>
<h3 id="定义-1">定义</h3>
<p><strong>马尔科夫随机场(Markov Random Field, MRF)</strong>
是典型的马尔可夫网，图中每个结点表示一个或一组变量，结点之间的边表示两个变量之间的依赖关系。马尔可夫随机场有一组<strong>势函数(Potential
functions)</strong>，也叫做因子(Factor)，是定义在变量子集上的非负实函数，主要用于定义概率分布函数。</p>
<p>对于图中结点的一个子集，若其中任意两个结点之间有边连接，则称该结点子集为一个<strong>“团”(clique)</strong>。若在一个团中加入另外任何一个结点都不再形成团，则称该团为<strong>“极大团”(maximal
clique)</strong>。下图为一个例子。</p>
<img src="/2022/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/image-20220607165747990.png" class="" title="image-20220607165747990">
<p>在马尔可夫随机场中，多个变量之间的联合概率分布能基于团分解为多个因子的乘积，每个因子仅与一个团有关。具体来说，对于
<span class="math inline">\(n\)</span> 个变量 <span
class="math inline">\(\mathbf{x}=\lbrace x_1,x_2,\cdots,x_n
\rbrace\)</span> ，所有团构成的集合为 <span
class="math inline">\(C\)</span> ，与团 <span class="math inline">\(Q
\in C\)</span> 对应的变量集合记为 <span
class="math inline">\(\mathbf{x}_Q\)</span> ，则联合概率 <span
class="math inline">\(P(\mathbf{x})\)</span> 定义为 <span
class="math display">\[
P(\mathbf{x})=\frac{1}{Z} \prod_{Q\in C} \psi_Q (\mathbf{x}_Q)
\]</span> 其中，</p>
<ul>
<li><span class="math inline">\(\psi_Q (\mathbf{x}_Q)\)</span> 为与团
<span class="math inline">\(Q\)</span> 对应的势函数，用于与团 <span
class="math inline">\(Q\)</span> 中的变量关系进行建模，</li>
<li><span class="math inline">\(Z=\sum_{\mathbf{x}} \prod_{Q\in C}
\psi_Q (\mathbf{x}_Q)\)</span> 为规范化因子，以确保 <span
class="math inline">\(P(\mathbf{x})\)</span> 是被正确定义的概率。</li>
</ul>
<p>联合概率 <span class="math inline">\(P(\mathbf{x})\)</span>​
可基于极大团来定义。假设所有极大团构成的集合为 <span
class="math inline">\(C^*\)</span>​ ，则 <span class="math display">\[
P(\mathbf{x})=\frac{1}{Z^*} \prod_{Q\in C^*} \psi_Q (\mathbf{x}_Q)
\]</span> 其中，</p>
<ul>
<li><span class="math inline">\(Z=\sum_{\mathbf{x}} \prod_{Q\in C^*}
\psi_Q (\mathbf{x}_Q)\)</span> 为规范化因子。</li>
</ul>
<h3 id="性质">性质</h3>
<p>对马尔可夫随机场，有</p>
<ul>
<li><p>全局马尔可夫性(Global Markov
property)：给定两个变量子集的分离集，则这两个变量子集<strong>条件独立</strong>。</p></li>
<li><p>局部马尔可夫性(Local Markov
property)：给定某变量的<strong>邻接变量</strong>，则该变量条件独立于其他变量。形式化的说，令
<span class="math inline">\(V\)</span> 为图的结点集，<span
class="math inline">\(n(v)\)</span> 为结点 <span
class="math inline">\(v\)</span> 在图上的邻接结点，<span
class="math inline">\(n^*(v)=n(v) \cup \lbrace v \rbrace\)</span> ，结点
<span class="math inline">\(v\)</span> 对应的变量集为 <span
class="math inline">\(\mathbf{x}_v\)</span> ，除去结点 <span
class="math inline">\(v\)</span> 和其邻接结点的结点集对应的变量集为
<span class="math inline">\(\mathbf{x}_{V \setminus
n^*(v)}\)</span>，结点 <span class="math inline">\(v\)</span>
的邻接结点的结点集对应的变量集为 <span
class="math inline">\(\mathbf{x}_{n(v)}\)</span>​ ，则有 <span
class="math display">\[
\mathbf{x}_v \bot \mathbf{x}_{V \setminus n^*(v)} |\mathbf{x}_{n(v)}
\]</span> 即 <span class="math inline">\(\mathbf{x}_v\)</span> 和 <span
class="math inline">\(\mathbf{x}_{V \setminus n^*(v)}\)</span> 在给定
<span class="math inline">\(\mathbf{x}_{n(v)}\)</span>
的条件下独立。</p></li>
<li><p>成对马尔可夫性(Pairwise Markov
property)：给定所有其他变量，两个<strong>非邻接变量</strong>条件独立。形式化的说，令
<span class="math inline">\(V\)</span> 为图的结点集，<span
class="math inline">\(E\)</span> 为图的边集，则对于图中的两个结点 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span> ，若 <span
class="math inline">\(&lt;u,v&gt; \notin E\)</span> ，则 <span
class="math display">\[
\mathbf{x}_v \bot \mathbf{x}_u |\mathbf{x}_{V \setminus &lt;u,v&gt;}
\]</span></p></li>
</ul>
<h3 id="势函数-psi_qmathbfx_q">势函数 <span
class="math inline">\(\psi_Q(\mathbf{x}_Q)\)</span></h3>
<p>势函数 <span class="math inline">\(\psi_Q(\mathbf{x}_Q)\)</span>
的作用是<strong>定量刻画变量集 <span
class="math inline">\(\mathbf{x}_Q\)</span>
中变量之间的相关关系</strong>，因此，它应该满足：</p>
<ul>
<li>是一个<strong>非负函数</strong>；</li>
<li>在<strong>所偏好的变量</strong>取值上有<strong>较大</strong>函数值。</li>
</ul>
<p>为了满足非负性，指数函数常被用于定义势函数，即 <span
class="math display">\[
\psi_Q(\mathbf{x}_Q) = e^{-H_Q(\mathbf{x}_Q)}
\]</span> 其中 <span class="math inline">\(H_Q(\mathbf{x}_Q)\)</span>
是一个定义在变量 <span class="math inline">\(\mathbf{x}_Q\)</span>​
上的实值函数，常见形式为 <span class="math display">\[
H_Q(\mathbf{x}_Q)=\sum_{u,v \in Q,u \ne v} \alpha_{uv}x_ux_v+\sum_{v \in
Q}\beta_v x_v
\]</span> 其中 $_{uv} $ 和 <span class="math inline">\(\beta_v\)</span>
为参数，第一项考虑每一对结点间的关系，第二项仅仅考虑单结点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/" class="post-title-link" itemprop="url">知识图谱构建技术综述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-04 14:35:59" itemprop="dateCreated datePublished" datetime="2022-06-04T14:35:59+08:00">2022-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-05 23:15:10" itemprop="dateModified" datetime="2022-06-05T23:15:10+08:00">2022-06-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="知识图谱构建技术综述">知识图谱构建技术综述</h1>
<h2 id="概述">概述</h2>
<h3 id="背景">背景</h3>
<p>深度学习具有局限性：</p>
<ol type="1">
<li>很大程度依赖大规模样本，缺乏先验知识；</li>
<li>本质上为映射，缺乏因果关系，难以推理；</li>
<li>缺乏可解释性。</li>
</ol>
<p>知识图谱的构建：知识抽取、知识表示、知识融合、知识推理。</p>
<h2 id="知识图谱的定义与架构">知识图谱的定义与架构</h2>
<h3 id="知识图谱的定义">知识图谱的定义</h3>
<p>知识图谱由结点（实体）和边（实体之间的关系）组成，本质上是一种语义网络，用于揭示万物之间的关系。</p>
<p>整体可划分为通用型知识图谱和领域型知识图谱。</p>
<p>应用：语义搜索、智能问答、辅助决策等。</p>
<p>通用表示：三元组形式，即 <span
class="math inline">\(G=(Entity_{head},Relation,Entity_{tail})\)</span>
，其中 <span class="math inline">\(Entity_{head}\)</span>
为头实体，<span class="math inline">\(Entity_{tail}\)</span>
为尾实体，<span class="math inline">\(Relation\)</span>
为两个实体之间的关系。</p>
<img src="/2022/06/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/image-20220605224347844.png" class="" title="image-20220605224347844">
<h3 id="知识图谱的体系架构">知识图谱的体系架构</h3>
<ol type="1">
<li>源数据的获取，即在各个类型的数据中获取有用的资源信息；</li>
<li>知识融合，用于关联多数据源的知识，扩大知识范围；</li>
<li>知识计算与知识应用。其中，知识计算是知识图谱能力输出的主要方式，知识应用是将知识图谱与特定领域或业务相结合以提高业务效率。</li>
</ol>
<img src="/2022/06/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/image-20220605224328022.png" class="" title="image-20220605224328022">
<h2 id="知识图谱构建技术">知识图谱构建技术</h2>
<h3 id="知识抽取">知识抽取</h3>
<p>知识抽取主要分为<strong>命名实体识别</strong>和<strong>关系抽取</strong>2个方面，主要可分为3类方法：</p>
<ol type="1">
<li>基于传统规则和模板；</li>
<li>基于统计机器学习；</li>
<li>基于深度学习。</li>
</ol>
<img src="/2022/06/04/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/image-20220605224626058.png" class="" title="image-20220605224626058">
<h4 id="命名实体识别">命名实体识别</h4>
<p>在命名实体识别方面，3类知识抽取方法具体如下：</p>
<h5 id="基于传统规则和模板的方法">基于传统规则和模板的方法</h5>
<p>在早期主要使用人工编写规则和模板的方法来实现。主要过程：首先由特定领域的专家构建大量的实体识别规则，然后将规则和文本相匹配从而抽取实体。</p>
<p>优点：准确率高；</p>
<p>缺点：耗费大量的人力物力，并且一套规则只能适用于一种领域，迁移性和泛化性很低。</p>
<h5 id="基于传统机器学习的方法">基于传统机器学习的方法</h5>
<p>基于传统机器学习的方法主要采用监督学习的方法，采用的模型有最大熵马尔可夫模型(Maximum
Entropy Markov Model, MEMM)、条件随机场(Conditional Random Field,
CRF)等。</p>
<p>优点：简单；</p>
<p>缺点：需要构造特征，且存在误差传播的问题。</p>
<h5 id="基于深度学习的方法">基于深度学习的方法</h5>
<p>基于深度学习的方法有卷积神经网络(Convolutional Neural Network, CNN)
和循环神经网络(Recurrent Neural Network, RNN) 两大类。</p>
<p>近年来所出现的命名实体识别方法对比：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 2%" />
<col style="width: 7%" />
<col style="width: 5%" />
<col style="width: 10%" />
<col style="width: 43%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="header">
<th>方法类别</th>
<th>年份</th>
<th>方法</th>
<th>数据集</th>
<th>模型</th>
<th>方法特点</th>
<th>适用场景</th>
<th>评测指标</th>
<th>评测值%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>基于传统规则的方法</td>
<td>1991</td>
<td>启发式方法</td>
<td>财经新闻</td>
<td>启发式算法+规则</td>
<td>较准确地自动提取实体，但构造规则的方法会耗费大量的人力，可移植性很差</td>
<td>财经新闻</td>
<td>Acc</td>
<td>97.50</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>参考文献：</p>
<p>张吉祥,张祥森,武长旭,等. 知识图谱构建技术综述[J].
计算机工程,2022,48(3):23-37. DOI:10.19678/j.issn.1000-3428.0061803.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/04/%EF%BC%88%E6%9D%8E%E5%AE%8F%E6%AF%85%EF%BC%89%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/%EF%BC%88%E6%9D%8E%E5%AE%8F%E6%AF%85%EF%BC%89%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习之卷积神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-06-04 00:00:14 / 修改时间：00:38:01" itemprop="dateCreated datePublished" datetime="2022-06-04T00:00:14+08:00">2022-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="convolutional-neural-networkcnn">Convolutional Neural
Network(CNN)</h1>
<h1 id="卷积神经网络">卷积神经网络</h1>
<p>本文章主要记录李宏毅老师在2021-2022年关于卷积神经网络的教学内容，具体可以查看B站的课程，链接为：https://www.bilibili.com/video/BV1Wv411h7kN?p=31.</p>
<p>本节主要内容讲述的是神经网络架构的设计和思路。</p>
<h2 id="引入">引入</h2>
<p>我们引入一个例子：图像分类（Image
Classification），也就是说，给一张图片给机器，机器需要去决定这张图片里面有什么样的东西。</p>
<ol type="1">
<li><p>输入</p>
<p>在下面的讨论中，我们假设我们的模型输入的图片大小是固定的，比如 <span
class="math inline">\(100 \times 100\)</span>。</p>
<p>当然，实际生活中，我们遇到的图像其实大小是不一的。遇到这种情况时，现在比较流行的做法还是把所有图片都先<strong>重新调整（Rescale）</strong>成大小一样再输入。</p></li>
<li><p>输出</p>
<p>我们模型的目标是分类，因此，我们会把每一个类别，表示成一个<strong>独热编码（One-hot）</strong>的<strong>向量（Vector）<span
class="math inline">\(\hat{y}\)</span></strong>
。如下图所示，如果一张图片对应的是猫的话，那么“猫”所对应的<strong>维度（dimension）</strong>的数值就是1，其余的维度（dimension）的数值就是0。那么这个维度的长度，就代表着你现在的模型可以辨识出多少不同种类的东西。</p></li>
<li><p>目标</p>
<p>模型的输出经过Softmax函数之后，我们可以得到一个向量 <span
class="math inline">\(y&#39;\)</span> 。我们希望 <span
class="math inline">\(y&#39;\)</span> 和 <span
class="math inline">\(\hat{y}\)</span> 的交叉熵（Cross
Entropy）越小越好。</p></li>
<li><p>问题</p>
<ol type="1">
<li><p>如何将一张图像视为一个模型的输入？</p>
<p>对于计算机系统而言，一张图像其实是一个<strong>三维</strong>的<strong>张量（tensor）</strong>。简单来讲，我们可以将维度大于2的矩阵视为张量。而这三维中，分别代表图片的<strong>宽、高和通道（Channel）的数目</strong>。那么，<strong>通道</strong>的意思是什么呢？一张彩色的图片，它的每一个像素点（Pixel）都是由RGB三种颜色组成，所以三个通道就代表了RGB三种颜色。而图片的宽和高就代表了这张图片的解析度，也就是像素点的数目。</p>
<p>我们将三维的张量“拉直”，就可以作为神经网络的输入了。对于这个“拉直”的向量，每一维的数值就代表了某一个位置的某一个颜色的强度。</p></li>
<li><p>在全连接网络（Fully Connected Network）中模型是如何工作的？</p>
<p>如图所示，我们将刚刚得到的向量（<span class="math inline">\(100
\times 100\times
3\)</span>）作为输入，输入到全连接网络中。假设第一层的神经元（Neuron）的数目有1000个，</p></li>
<li></li>
</ol></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">机器学习之简要介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-03 00:22:00" itemprop="dateCreated datePublished" datetime="2022-06-03T00:22:00+08:00">2022-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-04 17:49:26" itemprop="dateModified" datetime="2022-06-04T17:49:26+08:00">2022-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/2022/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/%E5%BC%95%E5%85%A5.png" class="" title="引入">
<h1 id="引入">引入</h1>
<h2 id="机器学习是什么">机器学习是什么？</h2>
<p>在网络上，我们经常听到关于机器学习、人工智能、深度学习的话题，那么，机器学习到底是什么？</p>
<p>简单来说，机器学习其实相当于构建一个映射函数。例如，在语音识别任务中，输入为语音片段，函数输出该语音片段对应的语言；在图像识别任务中，输入为一张图像，函数输出为该图像中的类别……</p>
<p>Tom Mitchell在1998年提出，"A computer problem is said to
<strong>learn</strong> from <strong>experience <span
class="math inline">\(E\)</span></strong> w.r.t. some <strong>task <span
class="math inline">\(T\)</span></strong> and some <strong>performance
measure <span class="math inline">\(P\)</span></strong>, if its
performance on <span class="math inline">\(T\)</span>, as measured by
<span class="math inline">\(P\)</span>, <strong>improves</strong> with
experience <span
class="math inline">\(E\)</span>."（对计算机系统而言，以<strong>性能量度
<span class="math inline">\(P\)</span>
</strong>进行衡量，如果一个计算机程序在<strong>某类任务 <span
class="math inline">\(T\)</span> </strong>上的性能，随着<strong>经验
<span class="math inline">\(E\)</span>
</strong>而提升，那么我们称这个计算机程序从经验 <span
class="math inline">\(E\)</span> 中学习。）</p>
<p>与之相比的是，对人类而言，学习是通过<strong>教授或体验</strong>而获得知识、技术、态度或价值的过程，从而导致<strong>可量度</strong>的<strong>稳定</strong>的行为变化。</p>
<img src="/2022/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/image-20220603004941595.png" class="" title="image-20220603004941595">
<h2 id="为什么要机器学习">为什么要机器学习？</h2>
<p>有一个很经典的例子，那就是对手写的数字进行图像识别：我们希望在给一个手写数字的图像给机器后，机器能够帮我们识别出，这个数字属于0~9之间的哪一个。</p>
<p>我们其实很难去编写一个程序来解决手写数字识别这样的问题。比如，我们如何区分2和7？简单的对每一个像素进行扫描识别他们的走势？这样的计算量极大，同时准确率也很低。而这个任务有一个很重要的特点：我们可以收集大量的包含了手写数字图像和对应数字的样本。</p>
<p>那么，我们是否可以通过学习这些样本，找到它们之间一些隐藏的特点，来生成一个能进行手写数字识别的程序？这就是机器学习的基本思路，而且，如果我们的工作足够好，这个程序也能识别新的手写数字的输入。</p>
<p>我们简单将为何要机器学习分为4点：</p>
<ol type="1">
<li>缺乏相关的专门知识。对一些任务，我们拥有专门知识，那么就可以用数学工具进行分析，但是还有很多任务，我们缺乏相关的专门知识，因此，我们通过学习大量样本，找到隐含的特征（这些特征可能没有很好的可解释性），然后来预测之后新的样本。</li>
<li>难以解释的人类经验。比如人脸/手写/语音识别，我们很难去用数学语言解释大脑是如何进行这些任务的，还有开车、坐飞机这种经验也很难解释。</li>
<li>快速变化的现象。有一些现象会快速变化，在经济领域中有信用评分和财务建模等，在医学领域中有诊断学，在金融领域有欺诈检测等，在这也就意味着需要不断学习新的模型。</li>
<li>需要定制。对于不同的人，需要定制不同的需求，比如个性化新闻阅读器和电影/书籍推荐。</li>
</ol>
<h2 id="机器学习的分类">机器学习的分类</h2>
<p><strong>机器学习按任务的分类：</strong></p>
<ol type="1">
<li><strong>监督学习（Supervised Learning）</strong></li>
<li><strong>无监督学习（Unsupervised Learning）</strong></li>
<li><strong>强化学习（Reinforcement Learning）</strong></li>
</ol>
<h3 id="监督学习">监督学习</h3>
<p>监督学习是指通过让机器学习大量<strong>带有标签的样本数据</strong>，训练出一个模型，并使该模型可以根据输入预测相应输出的过程。目标是根据<strong>标记数据（labeled
data）</strong>学习<strong>特征（feature）与标签（label）</strong>之间的<strong>映射函数（mapping
function）或关系（relationship）</strong>。</p>
<img src="/2022/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/image-20220604160144414.png" class="" title="image-20220604160144414">
<p>监督学习的预测目标为：</p>
<ul>
<li>分类（Classification）：输出为离散值</li>
<li>回归（Regression）：输出为连续值。</li>
</ul>
<p>例如对于一个普通的行人在街道行走的图像，如果是分类任务，我们的预测目标可以为行人和非行人，如果是回归任务，我们的预测目标可以是行人的目标。</p>
<p>常见的监督学习算法有：</p>
<ul>
<li>线性回归（Linear Regression）</li>
<li>罗辑斯特回归（Logistic Regression）</li>
<li>神经网络（Neural networks)</li>
<li>支持向量机（Support Vector Machines, SVMs）</li>
</ul>
<h3 id="无监督学习">无监督学习</h3>
<p>无监督学习是直接对输入数据进行建模，提取数据有效信息探索数据的整体结构。</p>
<p>无监督学习用于：</p>
<ol type="1">
<li>聚类（Clustering）</li>
<li>可视化（Visualization）和降维（Dimensionality reduction）</li>
<li>……</li>
</ol>
<p>常见的无监督学习算法有：</p>
<ol type="1">
<li>K均值算法（K-means）（用于聚类）</li>
<li>主成分分析（Principle Component Analysis, PCA）（用于降维）</li>
</ol>
<h3 id="强化学习">强化学习</h3>
<p>强化学习是通过一个<strong>智能体</strong>在与复杂而不确定的<strong>环境</strong>交互中<strong>最大化总回报</strong>来学习的一种计算方法。智能体以“试错”的方式进行学习，通过与环境交互获得的<strong>奖赏和惩罚</strong>指导行为，目标是使智能体<strong>获得最大的奖赏</strong>。</p>
<p>典型的应用就是棋子对弈和机器人自动控制。</p>
<h2 id="机器学习基本流程">机器学习基本流程</h2>
<p>机器学习是从有限的观测数据中学习（或者猜测）出具有一般性的规律，并且可以将总结出来的规律推广应用到未观测样本上。机器学习方法可以粗略的分为三个基本要素：模型、学习准则、优化算法。</p>
<p>机器模型的三要素：</p>
<ol type="1">
<li>模型
<ul>
<li>线性方法：<span
class="math inline">\(f(\mathbf{x},\theta)=\mathbf{w}^T
\mathbf{x}+b\)</span></li>
<li>广义线性方法：<span
class="math inline">\(f(\mathbf{x},\theta)=\mathbf{w}^T
\phi(\mathbf{x})+b\)</span> ，这里如果 <span
class="math inline">\(\phi(\mathbf{x})\)</span>
为可学习的非线性基函数，<span
class="math inline">\(f(\mathbf{x},\theta)\)</span>
就等价于神经网络。</li>
</ul></li>
<li>学习准则
<ul>
<li>最小化期望风险：<span
class="math inline">\(\mathcal{R}(f)=\mathbf{E}_{(\mathbf{x},y) \sim
p(\mathbf{x},y)} [\mathcal{L}(f(\mathbf{x},y)]\)</span></li>
<li>最大似然估计</li>
<li>最大后验估计</li>
</ul></li>
<li>优化：梯度下降</li>
</ol>
<h3 id="学习准则">学习准则</h3>
<p>令训练集 <span class="math inline">\(\mathcal{D}={\lbrace
\mathbf{x}^{(n)},y^{(n)} \rbrace}^N_{n=1}\)</span> 是由 <span
class="math inline">\(N\)</span>
个<strong>独立同分布</strong>的（Identically and Independently
Distributed, IID）样本组成，即每个样本 <span
class="math inline">\((\mathbf{x},y)\)</span> 是从输入空间 <span
class="math inline">\(\mathcal{X}\)</span> 和 输出空间 <span
class="math inline">\(\mathcal{Y}\)</span>
的联合空间中按照某个未知分布独立地随机产生的。这里要求样本分布必须是固定的（虽然可以是未知的），不会随着时间而变化。</p>
<p>一个好的模型 <span
class="math inline">\(f(\mathbf{x},\theta^*)\)</span> 应该在所有 <span
class="math inline">\((\mathbf{x},y)\)</span>
的可能取值上都与真实映射函数 <span
class="math inline">\(y=g(\mathbf{x})\)</span> 一致，即 <span
class="math display">\[
|f(\mathbf{x},\theta^*)-y| &lt; \epsilon ,\forall(\mathbf{x},y) \in
\mathcal{X}\times\mathcal{Y}
\]</span> 或与真实条件概率分布 <span
class="math inline">\(p_r(y|\mathbf{x})\)</span> 一致，即 <span
class="math display">\[
|f_y(\mathbf{x},\theta^*)-p_r(y|\mathbf{x})| &lt; \epsilon
,\forall(\mathbf{x},y) \in \mathcal{X}\times\mathcal{Y}
\]</span> 其中，<span class="math inline">\(\epsilon\)</span>
是一个很小的正数，<span
class="math inline">\(f_y(\mathbf{x},\theta^*)\)</span>
为模型预测的条件概率分布中 <span class="math inline">\(y\)</span>
对应的概率。</p>
<p>模型 <span class="math inline">\(f(\mathbf{x},\theta)\)</span>
的好坏可以通过期望风险（Expected Risk）<span
class="math inline">\(\mathcal{R}(\theta)\)</span>​ 来衡量，其定义为
<span class="math display">\[
\mathcal{R}(\theta) = \mathbf{E}_{(\mathbf{x},y) \sim p_r(\mathbf{x},y)}
[\mathcal{L}(y,f(\mathbf{x};\theta)]
\]</span> 其中，<span class="math inline">\(p_r(\mathbf{x},y)\)</span>
为真实的数据分布，<span
class="math inline">\(\mathcal{L}(y,f(\mathbf{x};\theta)\)</span>
为损失函数，用于量化两个变量之间的差异。</p>
<h3 id="损失函数">损失函数</h3>
<p><strong>损失函数是一个非负实数函数，用来量化模型预测和真实标签之间的差异。</strong></p>
<p>下面介绍几种常用的损失函数：</p>
<ul>
<li>0-1 损失函数</li>
<li>平方损失函数</li>
<li>感知器损失函数</li>
<li>Hinge损失函数</li>
<li>交叉熵损失函数</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-22 19:30:46 / 修改时间：20:26:54" itemprop="dateCreated datePublished" datetime="2022-03-22T19:30:46+08:00">2022-03-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高斯过程">高斯过程</h1>
<h2 id="准备">准备</h2>
<h3 id="深度学习的类型">深度学习的类型</h3>
<p>（1）监督学习</p>
<p>（2）无监督学习</p>
<p>（3）增强学习</p>
<h3 id="与概率之间的关系">与概率之间的关系</h3>
<p>有监督学习和无监督学习的区别就在于，求x的概率以及给定x求y的概率</p>
<h3 id="生成模型与判别模型">生成模型与判别模型</h3>
<p>深度学习和贝叶斯模型的区别在于，深度学习需要大量的数据集，而贝叶斯模型，由于给定了先验概率，所以需要的数据没有那么大。</p>
<h2 id="介绍">介绍</h2>
<h3 id="数据不足">数据不足</h3>
<p>Deterministic/Stochastic ：建立在物理模型上</p>
<p>Mechanistic/ Emipirical ：建立在经验模型上</p>
<p>高斯过程是随机过程的一种</p>
<p>物理模型不是足够精确的，数据不充分且模型不一定精确</p>
<h3 id="模型-pt-的需求">模型 <span class="math inline">\(p(t)\)</span>
的需求</h3>
<h3 id="高斯过程-1">高斯过程</h3>
<h3 id="高斯分布的优良性质">高斯分布的优良性质</h3>
<h2 id="高斯过程中的kernel">高斯过程中的Kernel</h2>
<p>构造核函数，希望能得到无限维的高斯分布来得到高斯过程</p>
<p>函数族，这些线性函数对应的是一个点</p>
<p>均值调整到(0,5)^T ，好像加了一些偏置，看起来有斜率了</p>
<p>20元的高斯分布，这里的每一条线是高斯分布的一个点</p>
<p>这时和机器学习有什么联系？</p>
<p>不够平滑，表现力不够强</p>
<p>平滑性</p>
<p>随机变量值 基本直觉 平方指数 核函数</p>
<p>用平方指数核函数来替代高斯分布里面的协方差矩阵 <span
class="math inline">\(cov(y_i;y_j)=\kappa (x_i;x_j)\)</span></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/" class="post-title-link" itemprop="url">机器学习之K均值、混合高斯模型和期望最大</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 10:03:28" itemprop="dateCreated datePublished" datetime="2022-03-21T10:03:28+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-02 17:32:58" itemprop="dateModified" datetime="2022-06-02T17:32:58+08:00">2022-06-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="机器学习之k均值混合高斯模型和期望最大">机器学习之K均值、混合高斯模型和期望最大</h1>
<p>提纲</p>
<ul>
<li>聚类与K均值</li>
<li>混合高斯模型与期望最大</li>
<li>期望最大的另一个视角</li>
<li>期望最大的另一个视角</li>
<li>期望最大的理论基础</li>
</ul>
<h2 id="聚类与k均值">聚类与K均值</h2>
<h3 id="示例">示例</h3>
<p>聚类是什么？举个例子，我们想把下图的人物归类，那么我们可以根据衣服样式归类，也可以根据性别、年龄等进行归类。</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321092330178.png" class="" title="image-20220321092330178">
<p>比如，我们想检测视频中的移动目标，这也是聚类的应用场景。</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321092356073.png" class="" title="image-20220321092356073">
<h3 id="聚类">聚类</h3>
<p>由上面的示例，我们对聚类应该有了一个大致的意识。聚类的基本思想就是将相似的实例分组在一起。什么才叫做相似的实例？如果两个点之间的距离足够近，那我们就认为他们是相似的，就像下图这种2D点的模式。</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321092634112.png" class="" title="image-20220321092634112">
<p>两个点之间距离的衡量有很多种方法，在这篇文章中，我们取欧式距离，公式如下：
<span class="math display">\[
dist(\boldsymbol{x},\boldsymbol{x})=||\boldsymbol{x}-\boldsymbol{y}||_2^2
\]</span> 其中，<span class="math inline">\(\boldsymbol{x}\)</span>
是一个向量，<span class="math inline">\(||\cdot||_2\)</span>
是两个向量之间的二范数，其计算方法为 <span
class="math inline">\(||\boldsymbol{x}||_2=(\sum \limits_{i=1}^n x_i^2)^
\frac{1}{2}\)</span> 。</p>
<p>我们的聚类结果取决于簇内相似度和簇间相似度，一般来说，我们希望簇内相似度更高，簇间相似度更低。</p>
<h3 id="聚类方法">聚类方法</h3>
<ul>
<li>原型聚类——K均值算法、高斯混合聚类</li>
<li>密度聚类——DBSCAN算法、Mean-Shift算法</li>
<li>层次聚类——–Agglomerative 算法、Divisive算法、BIRCH 算法</li>
<li>谱聚类</li>
</ul>
<h3 id="聚类例子">聚类例子</h3>
<p>我们举几个聚类所应用的场景。</p>
<ul>
<li><p>图像分割，目标：将图像分割成有意义的或感知上相似的区域</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321094023139.png" class="" title="image-20220321094023139"></li>
<li><p>基因表达数据聚类</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321094031460.png" class="" title="image-20220321094031460">
<p>[^]: Eisen et al,PNAS 1998</p></li>
<li><p>聚类新闻文章</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321094102368.png" class="" title="image-20220321094102368"></li>
<li><p>进化树</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321094107927.png" class="" title="image-20220321094107927">
<p>[^]: Lindbald-Toh et al., Nature 2005</p></li>
</ul>
<h3 id="k均值聚类">K均值聚类</h3>
<h4 id="准备">准备</h4>
<p>在 <span class="math inline">\(D\)</span> 维的欧式空间里，给定数据集
<span class="math inline">\({x_1,x_2,...,x_n}\)</span> ，将其划分为
<span class="math inline">\(K\)</span> 个簇（类），这是给定的<span
class="math inline">\(K\)</span> 个编码之一。同时引入指标变量 <span
class="math inline">\(r_{nk} \in \lbrace 0,1
\rbrace\)</span>，表示数据点 <span class="math inline">\(x_n\)</span>
属于K个聚类中的哪一个。</p>
<h4 id="失真度量">失真度量</h4>
<p>K均值算法针对聚类所得簇 <span class="math inline">\(C=\lbrace
C_1,C_2,...,C_K \rbrace\)</span> ，最小化平方误差和： <span
class="math display">\[
J=\sum \limits_{n=1}^N \sum \limits_{k=1}^K r_{nk} ||x_n-\mu_k||^2
\]</span> 其中，<span class="math inline">\(\mu_k = \frac{1}{|C_k|} \sum
\limits_{x \in C_k}x\)</span> ，是簇 <span
class="math inline">\(C_k\)</span> 的均值（<span class="math inline">\(k
= 1,2,...,K\)</span>）。</p>
<p>我们的目标其实就是找到 <span class="math inline">\(\lbrace r_{nk}
\rbrace\)</span> 和 <span class="math inline">\(\lbrace \mu_k
\rbrace\)</span> 的值，使得 <span class="math inline">\(J\)</span>
达到最小值。也就是说，我们希望找到对于每个簇 <span
class="math inline">\(C_k\)</span>
，找到它的指标变量和均值，使得簇内每个点的距离最小。直观来看，这个式子在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，<span
class="math inline">\(J\)</span> 值越小，簇内样本相似度越高。</p>
<p>我们可以⽤⼀种迭代的⽅法完成这件事，其中每次迭代涉及到两个连续的步骤，分别关于<span
class="math inline">\(\lbrace r_{nk} \rbrace\)</span> 的最优化和 <span
class="math inline">\(\lbrace \mu_k \rbrace\)</span> 的最优化。</p>
<h4
id="寻找lbrace-r_nk-rbrace-的最优化和-lbrace-mu_k-rbrace-的最优化">寻找<span
class="math inline">\(\lbrace r_{nk} \rbrace\)</span> 的最优化和 <span
class="math inline">\(\lbrace \mu_k \rbrace\)</span> 的最优化</h4>
<ol type="1">
<li>首先选择 <span class="math inline">\(\lbrace \mu_k \rbrace\)</span>
的初始值；</li>
<li>第一阶段：我们关于 <span class="math inline">\(r_{nk}\)</span>
最小化 <span class="math inline">\(J\)</span>，保持 <span
class="math inline">\(\mu_k\)</span> 固定；</li>
<li>第二阶段：我们关于 <span class="math inline">\(\mu_k\)</span> 最小化
<span class="math inline">\(J\)</span>，保持 <span
class="math inline">\(r_{nk}\)</span> 固定；</li>
</ol>
<p>注：两个阶段分别对应于EM算法中的E（期望）步骤和M（最⼤化）步骤，EM算法稍后会介绍，这里只是引入这样的一个概念。</p>
<h4 id="e参数-r_nk-的选择">E：参数 <span
class="math inline">\(r_{nk}\)</span> 的选择</h4>
<ol type="1">
<li><p>由于平方误差和 <span class="math inline">\(J=\sum \limits_{n=1}^N
\sum \limits_{k=1}^K r_{nk} ||x_n-\mu_k||^2\)</span> 是一个关于 <span
class="math inline">\(r_{nk}\)</span> 的线性函数（这里再次提醒，<span
class="math inline">\(r_{nk} \in \lbrace 0,1
\rbrace\)</span>，表示数据点 <span class="math inline">\(x_n\)</span>
属于 <span class="math inline">\(K\)</span>
个聚类中的哪一个），因此，这个优化问题存在解析解。</p></li>
<li><p>而显然，<span class="math inline">\(J=\sum \limits_{n=1}^N \sum
\limits_{k=1}^K r_{nk} ||x_n-\mu_k||^2 = \sum \limits_{k=1}^K
r_{1k}||x_1-\mu_k||^2+...+ \sum \limits_{k=1}^K
r_{Nk}||x_N-\mu_k||^2\)</span> ，其中有不同的 <span
class="math inline">\(n\)</span> 的项是独立的，因此，我们可以对每个
<span class="math inline">\(n\)</span> 分别进行最优化，只要 <span
class="math inline">\(k\)</span> 的值使得 <span
class="math inline">\(||x_n-\mu_k||^2\)</span> 最小，那么就使 <span
class="math inline">\(r_{nk}=1\)</span>。其实就是我们对于每一个数据点
<span class="math inline">\(x_n\)</span> ，都计算 <span
class="math inline">\(x_n\)</span> 与每个簇 <span
class="math inline">\(C_k\)</span> 的中心点（即 <span
class="math inline">\(\mu_k\)</span>）之间的距离，通过距离的比较，找到与
<span class="math inline">\(x_n\)</span> 最近的簇，将 <span
class="math inline">\(r_{nk}\)</span> 置为1，表示这个数据点 <span
class="math inline">\(x_n\)</span> 已经被分到簇 <span
class="math inline">\(C_k\)</span> 中了。</p></li>
<li><p>因此，我们可以对参数 <span class="math inline">\(r_{nk}\)</span>
选择如下： <span class="math display">\[
   r_{nk} =
   \begin{cases}
   1,  &amp; \text{if} \ k= \text{argmin}_j||x_n-\mu_j||^2 \\
   0, &amp; \text{otherwise}
   \end{cases}
   \]</span></p></li>
<li><p>直观地说，其实就是将 <span class="math inline">\(x_n\)</span>
分到最近的一个类里面。</p></li>
</ol>
<h4 id="m优化-mu_k">M：优化 <span
class="math inline">\(\mu_k\)</span></h4>
<ol type="1">
<li><p>固定 <span class="math inline">\(r_{nk}\)</span> ；</p></li>
<li><p>由于平方误差和 <span class="math inline">\(J=\sum \limits_{n=1}^N
\sum \limits_{k=1}^K r_{nk} ||x_n-\mu_k||^2\)</span> 是一个关于 <span
class="math inline">\(\mu_k\)</span> 的线性函数，（这里提醒一句，<span
class="math inline">\(\mu_k = \frac{1}{|C_k|} \sum \limits_{x \in
C_k}x\)</span> ，是簇 <span class="math inline">\(C_k\)</span>
的均值（<span class="math inline">\(k =
1,2,...,K\)</span>）因此，我们只要令 <span
class="math inline">\(J\)</span> 关于 <span
class="math inline">\(\mu_k\)</span> 的导数等于零，<span
class="math inline">\(J\)</span> 即可达到最小值。</p></li>
<li><p>求解过程为： <span class="math display">\[
2\sum \limits_{n=1}^N r_{nk}(x_n-\mu_k)=0
\]</span> 解出结果为 <span class="math display">\[
\mu_k = \frac{\sum_n r_{nk}x_n}{\sum_n r_{nk}}
\]</span></p></li>
<li><p>直观地说，其实就是令 <span class="math inline">\(\mu_k\)</span>
等于类别为 <span class="math inline">\(k\)</span>
的所有数据点的均值，<span class="math inline">\(\sum_n r_{nk}\)</span>
为类别为 <span class="math inline">\(k\)</span>
的所有数据点的数量，<span class="math inline">\(\sum_n
r_{nk}x_n\)</span> 等于类别为 <span class="math inline">\(k\)</span>
的所有数据点的总和。</p></li>
</ol>
<h4 id="k均值算法终止">K均值算法终止</h4>
<p>K均值算法，就是重复执行上述的选择 <span
class="math inline">\(r_{nk}\)</span> 和优化 <span
class="math inline">\(\mu_k\)</span>
的步骤，即重复分配数据点给簇（或类）和重复计算簇（或类）中心，直到聚类的分配不改变。由于每个阶段都减小了目标函数
<span class="math inline">\(J\)</span>
的值，因此算法的收敛性得到了保证。</p>
<h4 id="示例来自prml">示例（来自PRML）</h4>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321210022034.png" class="" title="image-20220321210022034">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321210028211.png" class="" title="image-20220321210028211">
<ul>
<li><span class="math inline">\(J\)</span>
是老忠实间歇喷泉数据的代价函数。</li>
<li>我们故意将聚类中⼼选择了较差的初始值，从⽽算法在收敛之前执⾏了若⼲步。更好的选择是将聚类中⼼选择为由k个随机数据点组成的⼦集。</li>
<li>K均值算法本身经常被用于在EM算法之前初始化高斯混合模型的参数。（这里出现了一个新概念：混合高斯模型，什么是混合高斯模型，这就是接下来要介绍的。）</li>
</ul>
<h3 id="局部最小值">局部最小值</h3>
<p>K均值算法的目标函数 <span class="math inline">\(J=\sum
\limits_{n=1}^N \sum \limits_{k=1}^K r_{nk} ||x_n-\mu_k||^2\)</span>
是非凸的，因此，并不能保证 <span class="math inline">\(J\)</span>
上的坐标下降收敛到全局最小值，没有什么办法能够阻止K均值陷入局部极小值。我们可以尝试更多随机初始化的点，或者尝试非局部拆分和合并操作，非局部拆分就是同时合并相邻的两个簇，合并操作就是将一个大的簇分为两个。</p>
<h3 id="k均值算法的性质">K均值算法的性质</h3>
<ol type="1">
<li>保证在有限次迭代中收敛。</li>
<li>每次迭代的训练时间：将数据点分配到最近的簇中心是 <span
class="math inline">\(O(KN)\)</span> 时间，根据分配的点改变聚类中心是
<span class="math inline">\(O(N)\)</span> 时间。</li>
</ol>
<h3 id="k均值的局限">K均值的局限</h3>
<ul>
<li>在每⼀次迭代中，每个数据点被分配到⼀个唯⼀的聚类中（“硬”分配）<br />
</li>
<li>某些点可能到两个聚类中心的距离相等</li>
<li>通过使⽤概率的⽅法，我们得到对数据点聚类的“软”分配，它反映出在最合适聚类分配上的不确定性</li>
</ul>
<h4 id="图像分割与压缩">图像分割与压缩</h4>
<p>之前提到，聚类算法其实可以用于图像分割与压缩。我们的目标是，将图像分割成若干的区域，每个区域有⼀个相对相似的视觉外观，或者对应于某个物体，或物体的⼀部分。在计算机图像中，每个像素是⼀个3维空间中的⼀个点，三维空间由{红、绿、蓝}
通道的三个亮度值构成，每个值由8比特的精度存储。</p>
<p>K均值聚类与K个颜色的调色板一起使用，该方法没有考虑不同像素的空间上的近似性。</p>
<h5 id="图像分割">（1）图像分割</h5>
<p>以下是选择2、3和10种颜色对彩色图像进行编码的两个示例：</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220321210941474.png" class="" title="image-20220321210941474">
<p>（2）数据压缩</p>
<ul>
<li><p>无损数据压缩：能够从压缩的表⽰中精确地重建原始数据。</p></li>
<li><p>有损数据压缩：接受重建过程中出现的⼀些错误。</p></li>
<li><p>K-Means应用于有损数据压缩</p>
<ul>
<li>对于 $ N $ 个数据点中的每一个，我们只存储它被分配的聚类种类 <span
class="math inline">\(k\)</span>。</li>
<li>我们还存储了 <span class="math inline">\(K\)</span>个聚类中心 <span
class="math inline">\(μ_k\)</span>
的值，这通常需要存储小得多的数据,其中我们假定 <span
class="math inline">\(K ≪ N\)</span>。这样，每个数据点都根据它最近的中心
<span class="math inline">\(μ_k\)</span>
确定。新的数据点可以类似地压缩。</li>
<li>首先找到最近的 <span
class="math inline">\(μ_k\)</span>，然后存储标签 <span
class="math inline">\(k\)</span> 而不是原始的数据向量</li>
</ul>
<p>这个框架被称为向量量子化(vector quantization)，向量 <span
class="math inline">\(μ_k\)</span> 被称为编码书向量 (code-book
vector)。</p></li>
<li><p>上面讨论的图像分割问题也说明了数据压缩中聚类的使用。</p>
<ul>
<li>假设原始图像有 $ N $ 个像素，每个像素由$ {R, G, B} <span
class="math inline">\(三个值组成，每个值由\)</span> 8 <span
class="math inline">\(比特的精度存储。这样，直接传递整幅图像需要\)</span>
24N $比特。</li>
<li>现在假设我们首先在图像数据上运行K均值算法，然后，我们不直接传递原始像素亮度向量，而是传递最近的向量$
_k <span class="math inline">\(的亮度。由于有\)</span> K <span
class="math inline">\(个这样的向量，因此每个像素需要\)</span> _2K
$比特。</li>
<li>我们还必须传送$ K <span class="math inline">\(个编码书向量\)</span>
_k <span class="math inline">\(，这需要\)</span> 24K $比特</li>
<li>因此传递这个图像所需的比特总数为$ 24K + N _2K
$（四舍五入到最近的整数）</li>
<li>当 <span class="math inline">\(K=2,3\)</span> 以及 <span
class="math inline">\(10\)</span>
时，压缩为原来的比例分别为4%，8%，17%</li>
</ul></li>
</ul>
<h2 id="混合高斯模型与期望最大">混合高斯模型与期望最大</h2>
<h3 id="单高斯模型">单高斯模型</h3>
<p>一维高斯（正态）分布的概率密度函数如下： <span
class="math display">\[
f(x)=\frac{1}{\sqrt{2 \pi} \sigma}
\text{exp}(-\frac{(x-\mu)^2}{2\sigma^2})
\]</span> 其中，<span class="math inline">\(\mu\)</span> 和 <span
class="math inline">\(\sigma^2\)</span> 分别是高斯分布的均值和方差。</p>
<h3 id="二维高斯模型">二维高斯模型</h3>
<p>多维变量 <span class="math inline">\(X=\lbrace x_1,x_2,...,x_n
\rbrace\)</span> 的联合概率密度函数为： <span class="math display">\[
f(X)=\frac{1}{(2\pi)^{d/2}|\Sigma|^{1/2}}\exp[-\frac{1}{2}(X-\mu)^T
\Sigma ^{-1}(X-\mu)],X=(x_1,x_2,...,x_n)
\]</span> 其中，<span class="math inline">\(d\)</span>
为变量维度，对于二维高斯分布，有 <span
class="math inline">\(d=2\)</span> ；<span class="math inline">\(u =
\begin{pmatrix} u_1 \\ u_2 \\ ...\\ u_n\end{pmatrix}\)</span>
，为各维变量的均值，<span class="math inline">\(\Sigma\)</span>
为协方差矩阵，描述各维变量之间的相关度，对于二维高斯分布，有 <span
class="math display">\[
\Sigma = \begin{bmatrix} \delta_{11} \ \delta_{12} \\ \delta_{21} \
\delta_{22}\end{bmatrix}
\]</span></p>
<h3 id="高斯混合模型-gmm">高斯混合模型 (GMM)</h3>
<p>一个高斯混合模型能表示成如下分布： <span class="math display">\[
p(x) = \sum\limits_{k=1}^K\pi_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span> 其中 <span
class="math inline">\(\mathcal{N}(x|\mu_k,\Sigma_k)\)</span>
就是上面的多维变量的高斯模型。而混合系数 <span
class="math inline">\(\pi_k\)</span> 满足 <span class="math inline">\(0
\le \pi_k \le 1\)</span> 和 <span class="math inline">\(\sum
\limits_{k=1}^K \pi_k = 1\)</span> 。</p>
<p>某个混合高斯模型融合的高斯模型个数足够多，它们之间的权重设定得足够合理，这个混合模型可以拟合任意分布的样本。</p>
<h3 id="一维高斯混合函数的边缘分布">一维高斯混合函数的边缘分布</h3>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220328224144606.png" class="" title="image-20220328224144606">
<p>⾼斯混合概率分布可以写成高斯分布的线性叠加的形式</p>
<h3 id="二维高斯混合函数的边缘分布">二维高斯混合函数的边缘分布</h3>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BK%E5%9D%87%E5%80%BC%E3%80%81%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9C%9F%E6%9C%9B%E6%9C%80%E5%A4%A7/image-20220328224207091.png" class="" title="image-20220328224207091">
<h3 id="gmms-和隐变量">GMMs 和隐变量</h3>
<p>我们引入离散潜在变量 <span class="math inline">\(z\)</span>
来描述高斯混合模型，更加深刻地认识这个重要的分布，开始了解期望最大化算法。</p>
<p>首先，我们已经知道，<span class="math inline">\(K\)</span>
个高斯分布的线性叠加 <span class="math display">\[
p(x) = \sum\limits_{k=1}^K\pi_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span> 然后，我们可以引入一个 <span class="math inline">\(K\)</span>
维的二维随机变量 <span class="math inline">\(z\)</span> ，用 1-of-K
表示（one-hot 变量），即 <span class="math inline">\(z = \lbrace
z_1,z_2,...,z_k \rbrace\)</span> ，其中 <span class="math inline">\(z_k
\in \lbrace 0,1 \rbrace\)</span> 且 <span class="math inline">\(\sum_k
z_k=1\)</span> ，向量 <span class="math inline">\(z\)</span> 有 <span
class="math inline">\(K\)</span> 种可能的状态。</p>
<p>那么，我们就可以确定边缘概率分布 <span
class="math inline">\(p(z)\)</span> 了。</p>
<h3 id="确定边缘概率分布-pz">确定边缘概率分布 <span
class="math inline">\(p(z)\)</span></h3>
<p>我们将概率与每个组件 <span class="math inline">\(z_k\)</span>
相关联。那么它们的关系要怎么连接呢？将 <span
class="math inline">\(z\)</span> 的边缘概率分布根据混合系数<span
class="math inline">\(π_k\)</span> 进⾏赋值，即 <span
class="math display">\[
p(z_k = 1)=\pi_k
\]</span> 其中 <span class="math inline">\(k\)</span> 满足 <span
class="math inline">\(0 \le \pi_k \le 1\)</span> 且 <span
class="math inline">\(\sum_k \pi_k = 1\)</span> 。</p>
<p>由于 <span class="math inline">\(z\)</span> 使用了“ 1-of-K ”
的表示方法，因此 <span class="math inline">\(z\)</span>
的边缘概率分布也可以写成 <span class="math display">\[
p(z)=\prod \limits_{k=1}^K \pi_k^{z_k}
\]</span> 当有1个分量时，<span class="math inline">\(p(z_1) =
\pi_k^{z_1}\)</span> ；当有2个分量时，<span
class="math inline">\(p(z_1,z_2)=\pi_1^{z_1}\pi_2^{z_2}\)</span> 。</p>
<h3 id="确定条件概率-pxz">确定条件概率 $p(x|z) $</h3>
<p>给定 <span class="math inline">\(z\)</span> 的⼀个特定的值，<span
class="math inline">\(x\)</span> 的条件概率分布是⼀个高斯分布 <span
class="math display">\[
p(x|z_k=1) = \mathcal{N}(x|\mu_k,\Sigma_k)
\]</span> 因此，条件概率 $p(x|z) $可以写成如下形式： <span
class="math display">\[
p(x|z) = \prod \limits_{k=1}^K \mathcal{N}(x|\mu_k,\Sigma_k)^{z_k}
\]</span> 由于指数 <span class="math inline">\(z_k\)</span>
的存在，这个连乘中除了一个乘积项之外其余的都等于1.</p>
<h3 id="联合分布">联合分布</h3>
<p>定义隐变量 <span class="math inline">\(z\)</span> 和观测变量 <span
class="math inline">\(x\)</span> 的联合分布 <span
class="math display">\[
p(x, z)=p(z)p(x|z)
\]</span> 其中，<span class="math inline">\(x\)</span> 为观测变量，<span
class="math inline">\(z\)</span> 为隐变量，<span
class="math inline">\(p(z)\)</span> 为边缘分布，<span
class="math inline">\(p(x|z)\)</span>为条件分布。</p>
<h3 id="边缘概率分布px">边缘概率分布p(x)</h3>
<p>由于联合分布是 <span class="math inline">\(p(x,
z)=p(z)p(x|z)\)</span> ，因此，<span class="math inline">\(x\)</span>
的边缘分布可以通过将联合概率分布对所有可能的 <span
class="math inline">\(z\)</span> 求和的方式得到，即 <span
class="math display">\[
\begin{aligned}
p(x) &amp; = \sum\limits_zp(z)p(x|z) \\
&amp; = \sum\limits_z(\prod \limits_{k=1}^K \pi_k^{z_k}
\mathcal{N}(x|\mu_k,\Sigma_k)^{z_k}) \\
&amp; = \sum\limits_{k=1}^K\pi_k\mathcal{N}(x|\mu_k,\Sigma_k)
\end{aligned}
\]</span> <span class="math inline">\(x\)</span>
的分布是高斯混合模型的标准形式。</p>
<p>对联合概率分布 <span class="math inline">\(p(x, z)\)</span>
操作，⽽不是对边缘概率分布 <span class="math inline">\(p(x)\)</span>
操作，这会产⽣极⼤的计算上的简化。</p>
<h3 id="另一个条件概率-responsibilitypzx">另一个条件概率
(Responsibility)<span class="math inline">\(p(z|x)\)</span></h3>
<p>另一个起着重要作用的量是给定$ x <span
class="math inline">\(的条件下，\)</span> z <span
class="math inline">\(的条件概率。我们会用\)</span> (z_k) <span
class="math inline">\(表示\)</span> p(z_k=1|x)
$，它的值可以使用贝叶斯定理求出 $ <span
class="math display">\[\begin{eqnarray} \gamma(z_k) \equiv p(z_k = 1|x)
&amp; = &amp; \frac{p(z_k = 1)p(x|z_k =
1)}{\sum\limits_{j=1}^Kp(z_j=1)p(x|z_j = 1)} \ &amp; = &amp;
\frac{\pi_k\mathcal{N}(x|\mu_k,\Sigma_k)}{\sum\limits_{j=1}^K\pi_j\mathcal{N}(x|\mu_j,\Sigma_k)}\end{eqnarray}\]</span>
$ 我们将 $ _k $ 看成 $ z_k = 1 $ 的先验概率，将 $ (z_k) $ 看成观测到$ x
<span
class="math inline">\(之后，对应的后验概率。正如我们将看到的那样，\)</span>
(z_k) $ 也可以被看做分量 $ k $ 对于“解释”观测值 <span
class="math inline">\(x\)</span> 的“责任”（responsibility）。</p>
<h3 id="gmm的最大似然">GMM的最大似然</h3>
<p>假设我们有⼀个观测的数据集 <span
class="math inline">\(x_1,x_2,...,x_N\)</span>
，我们希望使用混合高斯模型来对数据进行建模（ <span
class="math inline">\(N\)</span> 条数据，维度都为 <span
class="math inline">\(D\)</span> ），则数据集可以表示成 <span
class="math inline">\(N×D\)</span> 的矩阵 <span class="math inline">\(X
= \begin{bmatrix} \mathbf{x}_1 \\ \mathbf{x}_2 \\ ...
\\\mathbf{x}_N\end{bmatrix}\)</span> ， <span
class="math inline">\(\mathbf{x}_n = [\mathbf{x}_{n1} \ \mathbf{x}_{n2}
\ ...\  \mathbf{x}_{nD}]\)</span> 。对应隐含变量会被表示为⼀个 <span
class="math inline">\(N×K\)</span> 的矩阵 <span class="math inline">\(Z
= \begin{bmatrix} \mathbf{z}_1 \\ \mathbf{z}_2 \\ ...
\\\mathbf{z}_N\end{bmatrix}\)</span>， <span
class="math inline">\(\mathbf{z}_n = [\mathbf{z}_{n1} \ \mathbf{z}_{n2}
\ ...\  \mathbf{z}_{nK}]\)</span>。</p>
<p>目标是表示这个似然函数，从而通过最大化似然函数来估计这三组参数 <span
class="math inline">\(\pi_k,\mu_k,\Sigma_k\)</span></p>
<p>混合密度函数为 <span class="math display">\[
p(x) = \sum\limits_{k=1}^K\pi_k\mathcal{N}(x|\mu_k,\Sigma_k)
\]</span> 因此，对数似然函数为 <span class="math display">\[
\ln p(\boldsymbol{X} \mid \boldsymbol{\pi}, \boldsymbol{\mu},
\boldsymbol{\Sigma})=\sum_{n=1}^{N} \ln \left\{\sum_{k=1}^{K} \pi_{k}
\mathcal{N}\left(\boldsymbol{x}_{n} \mid \boldsymbol{\mu}_{k},
\boldsymbol{\Sigma}_{k}\right)\right\}
\]</span> 这是一个比单一高斯更难的问题。</p>
<h3 id="最大化对数似然函数">最大化对数似然函数</h3>
<p>目标是估计以下三个参数集 <span
class="math inline">\(\pi_k,\mu_k,\Sigma_k\)</span>​
，Ø在保持其他导数不变的情况下，依次求导数，但是没有解析解。这项任务并不简单，因为对k的求和出现在对数计算内部，从而对数函数不再直接作用于高斯分布。虽然基于梯度的优化是可能的，我们考虑更一般的迭代EM算法。</p>
<h3 id="gmm-最大似然估计的一些问题">GMM 最大似然估计的一些问题</h3>
<p>在最大化似然函数之前，简单地提两个技术问题：</p>
<p>• 病态解，即高斯混合的奇异性问题。</p>
<p>• 混合的可区分问题</p>
<h4 id="病态解">病态解</h4>
<p>我们考虑一个高斯混合模型，它的分量的协方差矩阵为 $ _k = _k^2I <span
class="math inline">\(，其中\)</span> I
$是一个单位矩阵，结论对于一般的协方差矩阵仍然成立。假设混合模型的第 $ j
$ 个分量的均值 $ _j $ 与某个数据点完全相同，即对于某个 $ n $ 值，$ _j =
x_n $ 。这样，这个数据点会为似然函数贡献一项，形式为</p>
<p><span class="math display">\[
\mathcal{N}(x_n|x_n,\sigma_j^2I) =
\frac{1}{(2\pi)^{D/2}}\frac{1}{\sigma_j^D}
\]</span> 如果我们考虑极限$ _j
$，那么我们看到这一项趋于无穷大，因此对数似然函数也会趋于无穷大。</p>
<p>回忆一下，这个问题在单一的高斯分布中没有出现。为了理解不同之处，我们注意到，如果单一的高斯分布退化到了一个数据点上，那么它总会给由其他数据点产生的似然函数贡献可乘的因子，这些因子会以指数的速度趋于0，从而使得整体的似然函数趋于零而不是无穷大。</p>
<p>使⽤合适的启发式⽅法可以避免这个问题：重置均值或协方差。</p>
<h4 id="可区分问题">可区分问题</h4>
<p>对于任意给定的最大似然解，一个由 <span
class="math inline">\(K\)</span> 个分量混合而成的概率分布总共会有 <span
class="math inline">\(K!\)</span> 个等价的解，对应于 <span
class="math inline">\(K!\)</span> 种将 <span
class="math inline">\(K\)</span> 个参数集合分配到 <span
class="math inline">\(K\)</span>
个分量上的方式。换句话说，对于参数值空间中任意给定的点，都会有 <span
class="math inline">\(K!−1\)</span>
个其他的点给出完全相同的概率分布。这个问题被称为可区分（identifiability）问题。但是，这个问题与找到一个好的概率模型无关，因为任意等价的解互相之间都一样好。</p>
<h3 id="用于高斯混合模型的em">用于高斯混合模型的EM</h3>
<p>终于突入这个问题了！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" class="post-title-link" itemprop="url">机器学习之线性回归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-21 00:07:10 / 修改时间：21:22:23" itemprop="dateCreated datePublished" datetime="2022-03-21T00:07:10+08:00">2022-03-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="机器学习之线性回归">机器学习之线性回归</h1>
<p>在准备华为昇腾RCNN的课程设计，暂时没有时间打公式，凑活着看吧=。=</p>
<p>之后会解释每个式子的直观解释的！</p>
<h2 id="线性回归">线性回归</h2>
<h3 id="线性模型">线性模型</h3>
<p>回归问题的最简单模型是输入变量的线性组合。 <span
class="math display">\[
y(\boldsymbol{x},\boldsymbol{w})=w_0+w_1x_1+...+w_Dx_D
\]</span> 其中，<span
class="math inline">\(\boldsymbol{x}=(x_1,...,x_D)^T\)</span></p>
<p>称为线性回归（linear regression）。</p>
<p>这个模型的关键性质：是参数 <span class="math inline">\(w_0,
…,w_D\)</span> 的⼀个线性函数。</p>
<h3 id="一般形式">一般形式</h3>
<ul>
<li>线性模型一般形式</li>
<li>向量形式</li>
</ul>
<h3 id="模型">模型</h3>
<p><span class="math display">\[
f(\boldsymbol{x};\boldsymbol{w},b)=\boldsymbol{w}^T\boldsymbol{x}+b
\]</span></p>
<ul>
<li>增广权重向量和增广特征向量 <span
class="math inline">\(f(\boldsymbol{x};\hat{\boldsymbol{w}})=\hat{\boldsymbol{w}}^T\hat{\boldsymbol{x}}\)</span></li>
</ul>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234627441.png" class="" title="image-20220316234627441">
<h3 id="优点">优点</h3>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234640197.png" class="" title="image-20220316234640197">
<h3 id="一元线性回归">一元线性回归</h3>
<ul>
<li><p>一元线性回归 <span class="math display">\[
f(x)=wx_i+b \text{使得}f(x_i)\simeq y_i
\]</span></p></li>
<li><p>参数/模型估计：最小二乘法（least square method）</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234834443.png" class="" title="image-20220316234834443"></li>
<li><p>最小化均方误差</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234848017.png" class="" title="image-20220316234848017"></li>
<li><p>分别对w和b求导</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234858233.png" class="" title="image-20220316234858233"></li>
<li><p>得到闭式解</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234908998.png" class="" title="image-20220316234908998">
<p>其中，</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234919459.png" class="" title="image-20220316234919459"></li>
</ul>
<h3 id="多元线性回归">多元线性回归</h3>
<ul>
<li><p>给定数据集</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234952472.png" class="" title="image-20220316234952472">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316234959106.png" class="" title="image-20220316234959106">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316235004841.png" class="" title="image-20220316235004841"></li>
<li><p>多元线性回归目标 <span class="math display">\[
f(\boldsymbol{x}_i)=\boldsymbol{w}^T\boldsymbol{x}_i+b
\text{使得}f(\boldsymbol{x}_i)\simeq y_i
\]</span></p></li>
<li><p>把 w 和 b 吸收进入向量形式，数据集表示为</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316235125794.png" class="" title="image-20220316235125794">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316235133775.png" class="" title="image-20220316235133775"></li>
<li><p>最小二乘法（least square method）</p>
<ul>
<li><p><span class="math display">\[
\hat{\boldsymbol{w}}^{*}= \text{argmin}_{\hat{w}} \left( \boldsymbol{y}-
\mathbf{X} \hat{ \boldsymbol{w}}^{ \boldsymbol{T}} \right) \left(
\boldsymbol{y} - \mathbf{X} \hat{ \boldsymbol{w}} \right)
\]</span></p></li>
<li><p>令 <span
class="math inline">\(E_{\hat{\boldsymbol{w}}}=\left(\boldsymbol{y}-\mathbf{X}\hat{\boldsymbol{w}}\right)^{\boldsymbol{T}}
\left(\boldsymbol{y}-\mathbf{X}\hat{\boldsymbol{w}}\right)\)</span> ，对
<span class="math inline">\(\hat{\boldsymbol{w}}\)</span> 求导得到 <span
class="math display">\[
\frac{\partial E_{\hat{\boldsymbol{w}}}}{\partial \hat{\boldsymbol{w}}}
=
2\mathbf{X}^{\rm{T}}\left(\mathbf{X}\hat{\boldsymbol{w}}-\boldsymbol{y}\right)
\]</span></p></li>
<li><p>令上式为零可得 <span
class="math inline">\(\hat{\boldsymbol{w}}\)</span> 最优解的闭式解 <span
class="math display">\[
\hat{\boldsymbol{w}}^{*}=\left(\mathbf{X}^{\rm{T}}\mathbf{X}\right)^{-1}
\mathbf{X}^{\boldsymbol{T}}\boldsymbol{y}
\]</span> 又称伪逆。</p></li>
</ul></li>
</ul>
<h3 id="满秩讨论">满秩讨论</h3>
<ul>
<li><img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220316235812685.png" class="" title="image-20220316235812685"></li>
<li>$^{} $ 不是满秩矩阵：
<ul>
<li>奇异值分解（SVD）</li>
<li>引入正则化</li>
</ul></li>
<li>并不是所有的函数都能通过输入变量直接线性地近似</li>
<li><img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000002862.png" class="" title="image-20220317000002862"></li>
<li>这样的情况下，我们需要采用输入变量的多项式或其它项来拟合函数，这样还是线性回归吗？</li>
<li>是的，只要对于系数是线性的就仍然是线性回归问题。</li>
</ul>
<h3 id="基函数">基函数</h3>
<ul>
<li>在一些应用中，我们对原始数据变量进行一些预处理或特征提取。</li>
<li>比如原始变量为x，特征可以表示为基函数的形式{φ(x)}。</li>
<li>通过采用基函数，我们使得线性模型可以是输入变量的非线性函数。</li>
</ul>
<h3 id="扩展模型">扩展模型</h3>
<ul>
<li><p>将输⼊变量的固定的⾮线性函数进⾏线性组合</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000139983.png" class="" title="image-20220317000139983">
<p><span class="math inline">\(\phi_j(\boldsymbol{x})\)</span>
被称为基函数（basis function）。</p></li>
<li><p>模型中的参数总数为 <span class="math inline">\(M\)</span></p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000231536.png" class="" title="image-20220317000231536">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000236259.png" class="" title="image-20220317000236259">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000243397.png" class="" title="image-20220317000243397"></li>
</ul>
<h3 id="基函数的选择">基函数的选择</h3>
<p>多项式曲线拟合</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000339208.png" class="" title="image-20220317000339208">
<p>其中，<span class="math inline">\(M\)</span>
是多项式的阶数（order），<span class="math inline">\(x^j\)</span> 表⽰
<span class="math inline">\(x\)</span> 的 <span
class="math inline">\(j\)</span> 次幂，多项式系数 <span
class="math inline">\(w_0 ,…,w_M\)</span> 整体记作向量 <span
class="math inline">\(\boldsymbol{w}\)</span>，多项式函数 <span
class="math inline">\(y(x,\boldsymbol{w})\)</span> 是 <span
class="math inline">\(x\)</span> 的⼀个⾮线性函数，是系数 <span
class="math inline">\(\boldsymbol{w}\)</span> 的⼀个线性函数。</p>
<ul>
<li><p>多项式基函数</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000607775.png" class="" title="image-20220317000607775">
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000617476.png" class="" title="image-20220317000617476"></li>
<li><p>“高斯”基函数</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000625242.png" class="" title="image-20220317000625242">
<ul>
<li>参数μj控制了基函数在输⼊空间中的位置，</li>
<li>参数s控制了基函数的空间⼤⼩</li>
</ul></li>
<li><p>sigmoid基函数</p>
<img src="/2022/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/image-20220317000650443.png" class="" title="image-20220317000650443"></li>
</ul>
<h2 id="最大似然与最小平方">最大似然与最小平方</h2>
<h3 id="最大似然与最小平方-1">最大似然与最小平方</h3>
<h3 id="最大似然">最大似然</h3>
<h3 id="boldsymbolw的解"><span
class="math inline">\(\boldsymbol{w}\)</span>的解</h3>
<h3 id="偏置参数w_0">偏置参数<span
class="math inline">\(w_0\)</span></h3>
<h3 id="噪声精度beta">噪声精度<span
class="math inline">\(\beta\)</span></h3>
<h2 id="正则化最小平方">正则化最小平方</h2>
<h3 id="正则化最小平方-1">正则化最小平方</h3>
<h3 id="最简单正则化项权值衰减">最简单正则化项——权值衰减</h3>
<h3 id="岭回归的闭式解">岭回归的闭式解</h3>
<h3 id="正则化项的几何解释">正则化项的几何解释</h3>
<h3 id="岭回归的最优解">岭回归的最优解</h3>
<h3 id="更加般的正则化项">更加⼀般的正则化项</h3>
<h3 id="正则化方法结论">正则化方法结论</h3>
<h2 id="偏置-方差分解">偏置-方差分解</h2>
<h3 id="回顾回归的决策论">回顾回归的决策论</h3>
<h3 id="偏置-方差分解-1">偏置-方差分解</h3>
<h3 id="偏置-方差折中">偏置-方差折中</h3>
<h3 id="偏置">偏置</h3>
<h3 id="方差">方差</h3>
<h3 id="监督学习中方差的来源">监督学习中方差的来源</h3>
<h3 id="偏置-方差之间的权衡">偏置-方差之间的权衡</h3>
<h2 id="贝叶斯线性回归">贝叶斯线性回归</h2>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/LinearProgramming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/19/LinearProgramming/" class="post-title-link" itemprop="url">LinearProgramming</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-19 17:30:41 / 修改时间：17:38:40" itemprop="dateCreated datePublished" datetime="2022-03-19T17:30:41+08:00">2022-03-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="组合设计与组合优化">组合设计与组合优化</h1>
<h2 id="线性规划">线性规划</h2>
<h3 id="线性规划问题的数学模型">1 线性规划问题的数学模型</h3>
<p>线性规划是最简单，应用最广泛的一种数学规划方法，也是使用最早的一种优化方法。从数学上说，线性规划问题可以归结为一类条件极值问题，用微积分方法来解决一般是无能为力的。</p>
<p>线性规划问题可归结为一类条件极值问题，即：在一组线性约束条件下，寻求一个线性函数的极大值或极小值。</p>
<p>目标函数： <span class="math display">\[
\text{max(min)} \ y = \sum \limits_{i=1}^r c_ix_i
\]</span> 约束条件： <span class="math display">\[
\begin{align}
s.t. \sum \limits_{i=1}^r a_{1i}x_i &amp; \le(=,\ge) b_1 \\\\
\sum \limits_{i=1}^r a_{2i}x_i &amp; \le(=,\ge) b_2 \\\\
......\\\\
  \sum \limits_{i=1}^r a_{2mi}x_i &amp; \le(=,\ge) b_m \\\\
\end{align}
\]</span> 非负约束条件： <span class="math display">\[
x_i \ge 0,i = 1,2,...,r
\]</span></p>
<h4 id="运输问题">（1）运输问题</h4>
<p>设有两个电视机厂A1,A2，产量分别为23万台与27万台，其产品供应三个城市B1,B2,B3。每个城市的需要量分别为17万台，18万台和15万台，而各厂到各城市的运费单价如下表。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>B₁</th>
<th>B₂</th>
<th>B₃</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A₁</td>
<td>50</td>
<td>60</td>
<td>70</td>
</tr>
<tr class="even">
<td>A₂</td>
<td>60</td>
<td>110</td>
<td>160</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th></th>
<th>B₁</th>
<th>B₂</th>
<th>B₃</th>
<th>总发量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A₁</td>
<td>X₁₁</td>
<td>X₁₂</td>
<td>X₁₃</td>
<td>23</td>
</tr>
<tr class="even">
<td>A₂</td>
<td>X₂₁</td>
<td>X₂₂</td>
<td>X₂₃</td>
<td>27</td>
</tr>
<tr class="odd">
<td>总收量</td>
<td>17</td>
<td>18</td>
<td>15</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>则我们可以定义其为一个线性规划问题： <span class="math display">\[
\begin{equation}
\begin{split}
\text{min} \ y = 50x_{11}+60x_{12}+70x_{13}+60x_{21}+110x_{22}+160x_{23}
\\\\
\begin{aligned}
s.t. \quad x_{11} + x_{12} + x_{13} &amp; = 23 \\\\
x_{21} + x_{22} + x_{23} &amp; = 27 \\\\
x_{11} + x_{21} &amp; = 17 \\\\
x_{12} + x_{22} &amp; = 18 \\\\
x_{13} + x_{23} &amp; = 15 \\\\
\end{aligned}
\\\\ x_{ij}  \ge 0,i=1,2;j=1,2,3
\end{split}
\end{equation}
\]</span></p>
<p>（2）生产计划问题</p>
<p>我们需要加工4种产品，分别为P1,P2,P3,P4，而我们拥有三种机床 A,B,C
，如果要加工产品就必须同时使用3种机床进行加工。而机床类型，机床数量以及每种机床加工产品的时间如下表：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 14%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
</colgroup>
<thead>
<tr class="header">
<th>机床类型</th>
<th>机床数量</th>
<th>P1（小时）</th>
<th>P2（小时）</th>
<th>P3（小时）</th>
<th>P4（小时）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>20</td>
<td>2</td>
<td>2</td>
<td>0.5</td>
<td>1.5</td>
</tr>
<tr class="even">
<td>B</td>
<td>30</td>
<td>0.5</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr class="odd">
<td>C</td>
<td>15</td>
<td>1.5</td>
<td>1</td>
<td>3</td>
<td>1.5</td>
</tr>
</tbody>
</table>
<p>每种产品的利润如下表：</p>
<table>
<thead>
<tr class="header">
<th>商品</th>
<th>P1</th>
<th>P2</th>
<th>P3</th>
<th>P4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>单个利润</td>
<td>3.5元</td>
<td>4.2元</td>
<td>6.5元</td>
<td>3.8元</td>
</tr>
</tbody>
</table>
<p>每台机床每周运行不超过60小时，为了使获得的利润达到最大，问每周应制造这些产品各多少件？</p>
<p>设 <span class="math inline">\(x_i\)</span> 为 每周制造产品 <span
class="math inline">\(P_i\)</span>
的数量，我们可以定义其为一个线性规划问题： <span class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = 3.5 x_1 + 4.2 x_2 + 6.5 x_3 + 3.8 x_4 \\\\
\begin{aligned}
s.t. 2x_{1} + 2x_{2} + 0.5x_{3} + 1.5x_{4} &amp; \le 1200 \\\\
0.5x_{1} + 2x_{2} + x_{3} + 2x_{4} &amp; \le 1800 \\\\
1.5x_{1} + x_{2} + 3x_{3} + 1.5x_{4} &amp; \le 800
\end{aligned}\\\\
x_{i}  \ge 0,i=1,2,3,4
\end{split}
\end{equation}
\]</span></p>
<h4 id="网络流问题">（3）网络流问题</h4>
<p>在之前所讨论的寻求运输网络中最大流的问题，实际上是一个线性规划问题。
<span class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ f_v = \sum \limits_{j \in V} f(s,j) \\\\
\begin{aligned}
s.t.\ &amp;  c(i,j) - f(i,j)  \ge 0 \\\\
&amp; \sum \limits_{\substack{i \in V \\\\ j \neq s,t}} f(i,j) - \sum
\limits_{ \substack{j \in V \\\\ j \neq s,t}} f(j,k)  = 0 \\\\
&amp; f(i,j) \ge 0,(i,j) \in E
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<h3 id="线性规划问题的几何意义">2 线性规划问题的几何意义</h3>
<h4 id="相关概念">（1）相关概念</h4>
<p><strong>可行解</strong>：满足以下约束条件 <span
class="math display">\[
\begin{split}
\begin{aligned}
s.t. \sum \limits_{i=1}^r a_{1i}x_i &amp; \le(=,\ge) b_1 \\\\
\sum \limits_{i=1}^r a_{2i}x_i &amp; \le(=,\ge) b_2 \\\\
......\\\\
  \sum \limits_{i=1}^r a_{2mi}x_i &amp; \le(=,\ge) b_m
\end{aligned}\
\\\\
x_i  \ge 0,i = 1,2,...,r
\end{split}
\]</span> 的变量 <span
class="math inline">\(x_1,x_2,...,x_r\)</span>的值。</p>
<p><strong>最优可行解</strong>：使目标函数 <span
class="math inline">\(y=\sum \limits_{i=1}^r c_ix_i\)</span>
取到最大值（或最小值）的可行解</p>
<p><strong>可行解域：</strong>所有可行解的集合</p>
<h4 id="例子">（2）例子</h4>
<p><strong>例1</strong>：给出一个线性规划问题如下： <span
class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = x_1 + x_2 \\\\
\begin{aligned}
s.t. 2x_1+3x_2 &amp; \le 6 \\\\
3x_1+2x_2 &amp; \le 6 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<p>则画图如下：</p>
<img src="/2022/03/19/LinearProgramming/image-20220319171444450.png" class="" title="例1-图1">
<img src="/2022/03/19/LinearProgramming/image-20220319171538409.png" class="" title="例1-图2">
<p>如图所示，在点 (6/5,6/5) ， <span class="math inline">\(y\)</span>
取得最大值 12/5 ，即最优可行解为 (6/5,6/5) 。</p>
<p><strong>例2</strong> 给出一个线性规划问题如下： <span
class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = 3x_1 + x_2 \\\\
\begin{aligned}
s.t. x_1+x_2 &amp; \le 5 \\\\
-x_1+x_2 &amp; \le 0 \\\\
6x_1+2x_2 &amp; \le 21 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<p>则画图如下：</p>
<img src="/2022/03/19/LinearProgramming/image-20220318114944778.png" class="" title="image-20220318114944778">
<img src="/2022/03/19/LinearProgramming/image-20220318115111885.png" class="" title="image-20220318115111885">
<p>如图所示，<span class="math inline">\(y\)</span> 可取得最大值 21/2
，但有无穷多个最优可行解。</p>
<p><strong>例3</strong> 给出一个线性规划问题如下： <span
class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = 2x_1 + 2x_2\\\\
\begin{aligned}
s.t. x_1 - x_2 &amp; \ge 1 \\\\
-x_1+2x_2 &amp; \le 0 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<p>则画图如下：</p>
<img src="/2022/03/19/LinearProgramming/image-20220318115306288.png" class="" title="image-20220318115306288">
<p>如图所示，可行解域无穷大，<span class="math inline">\(y\)</span>
无法取到最大值， 有无穷多个最优可行解。</p>
<p><strong>例4</strong> 给出一个线性规划问题如下： <span
class="math display">\[
\begin{equation}
\begin{split}
\text{min} \ y = 3x_1 + 2x_2 \\\\
\begin{aligned}
s.t. -x_1 + x_2 &amp; \ge 1 \\\\
x_1+x_2 &amp; \le -2 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<p>则画图如下：</p>
<img src="/2022/03/19/LinearProgramming/image-20220318115526464.png" class="" title="image-20220318115526464">
<p>如图所示，没有可行解，因此 <span class="math inline">\(y\)</span>
无法取到最大值，没有最优可行解。</p>
<h4 id="解的4种情况">（3）解的4种情况</h4>
<p><strong>两个变量的线性规划问题的解可能有以下四种情况：</strong></p>
<p>1.有唯一的最优可行解。这个唯一的最优可行解一定是可行解域的一个顶点。</p>
<p>2.有最优可行解，但不唯一。此时最优可行解一定是可行解域的一条边界上的所有点。</p>
<p>3.有可行解，但没有最优可行解。此时在可行解域上，目标函数的值趋向无穷。</p>
<p>4.无可行解。此时可行解域为空集。</p>
<h3 id="凸多边形与凸多面体">3 凸多边形与凸多面体</h3>
<h4 id="相关概念-1">（1）相关概念</h4>
<p><strong>凸多边形：</strong>是指没有一个内角超过180。的多边形。或者说，一个多边形是凸的，如果联接这个多边形中任意两个点的线段上的所有点仍在这个多边形中.</p>
<p><strong>凸多边形的角点x：</strong>它在凸多边形中且不在凸多边形中任何两点（除x点外）的线段上。</p>
<p>具有两个变量的线性规划问题，其最优可行解如果存在，一定在角点上可以找到最优可行解。</p>
<p>推广到多维情形：</p>
<p><strong>凸多面体：</strong>如果联接这个多面体中任意两个点的线段上的所有点仍在这个多面体中。</p>
<h4 id="r-维空间中的点">（2）<span class="math inline">\(r\)</span>
维空间中的点</h4>
<p>在 <span class="math inline">\(r\)</span>
维空间中，一个点可以用这个点的 <span class="math inline">\(r\)</span>
个坐标来表示. <span class="math display">\[
\begin{split}
a_{i1}x_1+a_{i2}x_2+...+a_{ir}x_r=bi\\\\
a_{i1}x_1+a_{i2}x_2+...+a_{ir}x_r&gt;bi\\\\
a_{i1}x_1+a_{i2}x_2+...+a_{ir}x_r&lt;bi
\end{split}
\]</span></p>
<h4 id="线性规划问题的几何表示">（3）线性规划问题的几何表示</h4>
<p>对一个有 <span class="math inline">\(r\)</span> 个变元和 <span
class="math inline">\(m\)</span>
个线性约束条件的线性规划问题，可行解域是 <span
class="math inline">\(r\)</span>
维空间中的一个凸多面体，它由对应于线性约束条件的 <span
class="math inline">\(m\)</span> 个超平面和对应于非负条件的 <span
class="math inline">\(r\)</span> 个超平面所围成： <span
class="math display">\[
\begin{split}
a_{11}x_1+a_{12}x_2+...+a_{1r}x_r=b_1\\\\
a_{21}x_1+a_{22}x_2+...+a_{2r}x_r=b_2\\\\
...\\\\
a_{m1}x_1+a_{m2}x_2+...+a_{mr}x_r=b_m\\\\
x_i \ge 0,i = 1,2,...,r
\end{split}
\]</span> 对 <span class="math inline">\(r\)</span>
维空间的线性规划问题，如果存在最优可行解，那么在凸多面体的某个角点上一定能找到最优可行解。</p>
<p>在二维空间中，互不平行的两条直线相交于一点，在 <span
class="math inline">\(r\)</span> 维空间中，互不平行的 <span
class="math inline">\(r\)</span> 个超平面也相交于一个点。</p>
<h3 id="线性规划问题的标准形式">4 线性规划问题的标准形式</h3>
<h4 id="标准形式">（1）标准形式</h4>
<p>给定一个线性规划问题： <span class="math display">\[
\begin{equation}
\begin{split}
\text{max(min)} \ y = \sum  \limits_{i=1}^r c_ix_i \\\\
\begin{aligned}
s.t. \quad \sum \limits_{i=1}^r a_{1i}x_i &amp; \le(=,\ge) b_1 \\\\
\sum \limits_{i=1}^r a_{2i}x_i &amp; \le(=,\ge) b_2 \\\\
......\\\\
  \sum \limits_{i=1}^r a_{2mi}x_i &amp; \le(=,\ge) b_m \\\\
\end{aligned}\\\\
\quad x_i   \ge 0,i  = 1,2,...,r
\end{split}
\end{equation}
\]</span> 将其标准化，为 <span class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y  = \sum  \limits_{i=1}^r c_ix_i \\\\
\begin{aligned}
s.t.   \sum \limits_{i=1}^r a_{1i}x_i  &amp;= b_1 \\\\
\sum \limits_{i=1}^r a_{2i}x_i  &amp;= b_2 \\\\
......\\\\
  \sum \limits_{i=1}^r a_{2mi}x_i  &amp;= b_m \\\\
\end{aligned} \\\\
x_i   \ge 0,i  = 1,2,...,r
\end{split}
\end{equation}
\]</span></p>
<h4 id="标准化方法">（2）标准化方法</h4>
<p>（a）如果约束条件中出现了 <span class="math inline">\(&lt;,\le
,&gt;,\ge\)</span> ，则需要引入松弛变量： <span class="math display">\[
\begin{align}
a_{k1}x_1+a_{k2}x_2 +...+a_{kr}x_r \le b_k \\\\
\text{插入}{x_{r+k}\ge0}\Rightarrow a_{k1}x_1+a_{k2}x_2 +...+a_{kr}x_r
+x_{r+k}= b_k
\end{align}
\]</span></p>
<p><span class="math display">\[
\begin{align}
a_{k1}x_1+a_{k2}x_2 +...+a_{kr}x_r \ge b_k \\\\
\text{插入}{x_{r+k}\ge0}\Rightarrow a_{k1}x_1+a_{k2}x_2 +...+a_{kr}x_r
-x_{r+k}= b_k
\end{align}
\]</span></p>
<p>（b）如果线性规划问题求最小值，那么我们可以将等式左右取负转为求最大值问题：
<span class="math display">\[
\text{min} \ y = \sum  \limits_{i=1}^r c_ix_i \Rightarrow \text{max} \
y&#39; = -y = -\sum  \limits_{i=1}^r c_ix_i
\]</span> （c）如果约束条件中的 <span class="math inline">\(b_k
&lt;0\)</span> ，那么我们可以将等式左右取负将等式后边置为正值： <span
class="math display">\[
a_{k1}x_1+a_{k2}x_2 +...+a_{kr}x_r = b_k \Rightarrow\text{插入}{b_k &lt;
0}\Rightarrow -a_{k1}x_1-a_{k2}x_2 -...-a_{kr}x_r = -b_k
\]</span> （d）如果某个变量 <span class="math inline">\(x_i &lt;
0\)</span> ，做如下变换： <span class="math display">\[
x_i = x_i&#39;-x_i&#39;&#39;(x_i&#39;&#39; &gt; x_i&#39; \ge 0)
\]</span> （e）这样我们就可以得到标准化的线性规划问题： <span
class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = \sum  \limits_{i=1}^r c_ix_i \\\\
\begin{aligned}
s.t. \sum \limits_{i=1}^r a_{1i}x_i \pm x_{r+1} &amp; = b_1 \\\\
\sum \limits_{i=1}^r a_{2i}x_i \pm x_{r+2} &amp; = b_2 \\\\
......\\\\
\sum \limits_{i=1}^r a_{2mi}x_i \pm x_{r+m}  &amp; = b_m
\end{aligned}
\\\\
x_i   \ge 0,x_{r+j} \ge 0,i  = 1,2,...,r \\\\  
b_i  \ge 0,i=1,2,...,m
\end{split}
\end{equation}
\]</span></p>
<p>观察得到，<span
class="math inline">\((x_1,x_2,...,x_r,x_{r+1},x_{r+2},...x_{r+m})\)</span>
= <span class="math inline">\((0,0,...,0,b_1,b_2,...,b_m)\)</span>
是当前约束条件下</p>
<p>的一个可行解。</p>
<h3 id="线性规划问题的基本定理">5 线性规划问题的基本定理</h3>
<h4
id="基本可行解的相关概念">（1）<strong>基本可行解的相关概念</strong></h4>
<p><strong>基本可行解：</strong>一个可行解的 <span
class="math inline">\(r+m\)</span> 个分量中的 <span
class="math inline">\(r\)</span> 个分量都是0称为基本可行解；如果有多于
<span class="math inline">\(r\)</span>
个0的分量，则为退化的基本可行解。</p>
<p>基本可行解中，取非0值的变量称为<strong>基本变量</strong>，其他的称为<strong>非基本变量</strong>。</p>
<p><strong>最优基本可行解：</strong>使目标函数达到最优的基本可行解。</p>
<h4
id="最优基本可行解存在定理">（2）<strong>最优基本可行解存在定理</strong></h4>
<p><strong>最优基本可行解存在定理(线性规划问题基本定理）：</strong>如果线性规划问题存在最优可行解，则一定存在最优基本可行解。</p>
<p>这个定理的证明是构造性的，我们直接在后面的求解方法中介绍。</p>
<p><strong>推论：线性规划问题的最优可行解若存在，则必在可行解域的角点上找到。</strong></p>
<p>只需在可行解域的有限个角点处计算目标函数的值，然后将这些值进行比较，从中挑出最优的值。</p>
<p>当变量的数目和线性约束条件的数目增加时，可行解域中的角点就会大大增加，从而在每一角点处计算目标函数的值就会花费许多工作量。</p>
<h3 id="单纯形方法">6 单纯形方法</h3>
<h4 id="基本思想">（1）基本思想</h4>
<img src="/2022/03/19/LinearProgramming/image-20220318140958990.png" class="" title="image-20220318140958990">
<h4 id="存在问题">（2）存在问题</h4>
<ul>
<li>计算了目标函数在某一角点处的值之后，如何求得另一角点使得目标函数在该角点的值会更大些？</li>
<li>当可行解域的相应角点已经达到时，如何知道已经求得最优解？</li>
</ul>
<h4 id="例子-1">（3）例子</h4>
<p><span class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = x_1 + 4x_2 \\\\
\begin{aligned}
s.t. 4x_1 + 5x_2 &amp; \le 10 \\\\
5x_1 + 2x_2 &amp; \le 10\\\\
-7x_1+4x_2 &amp; \le 4 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span></p>
<p>标准化后，为：</p>
<p><span class="math display">\[
\begin{equation}
\begin{split}
\text{max} \ y = x_1 + 4x_2 \\\\
\begin{aligned}
s.t. 4x_1 + 5x_2 + x_3 &amp; = 10 \\\\
5x_1 + 2x_2 + x_4 &amp; = 10 \\\\
-7x_1+4x_2 +x_5 &amp; = 4 \\\\
x_1  &amp; \ge 0 \\\\ x_2 &amp; \ge 0\\\\
\end{aligned}
\end{split}
\end{equation}
\]</span> 注意这里 <span class="math inline">\(r=2,m=3\)</span></p>
<img src="/2022/03/19/LinearProgramming/image-20220318143957406.png" class="" title="image-20220318143957406">
<p>在 <span class="math inline">\(m\)</span> 个约束条件中，令 <span
class="math inline">\(r+m\)</span> 个变量的 <span
class="math inline">\(r\)</span> 个(非基本变量)为0，解出其余 <span
class="math inline">\(m\)</span>
个变量，就可以得到一个基本可行解，对应一个角点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Rebecca">
      <meta itemprop="description" content="弱小和无知不是生存的障碍，傲慢才是。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rebecca的赛博世界">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%B5%81/" class="post-title-link" itemprop="url">算法之网络流</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-14 23:24:24 / 修改时间：23:58:39" itemprop="dateCreated datePublished" datetime="2022-03-14T23:24:24+08:00">2022-03-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章大纲：</p>
<ol type="1">
<li>理解最大流、任意流、最小割、任意割之间的关系；</li>
<li>掌握网络最大流问题和最小割问题及其求解算法，给出一个网络能求出它的最大流或者最小割。</li>
</ol>
<h2 id="最大流和最小割问题">最大流和最小割问题</h2>
<ol type="1">
<li><p>流网络</p>
<ol type="1">
<li>一个流网络是一个图 <span
class="math inline">\(G=(V,E,s,t,c)\)</span>
<ol type="1">
<li><span class="math inline">\((V,E)\)</span> 为一个有向图，起点为
<span class="math inline">\(s\in V\)</span> ，终点为 <span
class="math inline">\(t \in V\)</span></li>
<li>对每一条边 <span class="math inline">\(e\in E\)</span> ，容量 <span
class="math inline">\(c(e) &gt; 0\)</span></li>
</ol></li>
</ol></li>
<li><p>最大流问题</p>
<ol type="1">
<li>一个流网络 <span class="math inline">\(f\)</span> 是一个函数，满足
<ol type="1">
<li>对于每一条边 <span class="math inline">\(e \in E\)</span> ： <span
class="math inline">\(0 \le f(e)\le c(e)\)</span></li>
<li>对于每一个结点 <span class="math inline">\(v \in V-\lbrace s, t
\rbrace\)</span> ： <span class="math inline">\(\sum_{e \in \ to \ v }
f(e)=\sum_{e \ out \ of \ v}\)</span></li>
</ol></li>
<li>流值 <span class="math inline">\(val(f)=\sum_{e \ out \ of \ s} f(e)
- \sum_{e \ in \  to \  s}\)</span></li>
<li>最大流问题：找到一个流的最大流值。</li>
</ol></li>
<li><p>最小割问题</p>
<ol type="1">
<li><p>一个割集是一个划分 <span class="math inline">\((A,B)\)</span>
，满足 <span class="math inline">\(s \in A\)</span> 和 <span
class="math inline">\(t\in B\)</span></p></li>
<li><p>割集的容量是从 <span class="math inline">\(A\)</span> 到 <span
class="math inline">\(B\)</span>​ 的所有边的容量之和 <span
class="math display">\[
cap(A,B)=\sum_{e \ out \ of \ A}c(e)
\]</span></p></li>
<li><p>最小割问题：找到一个割的最小容量</p></li>
</ol></li>
</ol>
<h2 id="fordfulkerson算法">Ford–Fulkerson算法</h2>
<ol type="1">
<li><p>贪心算法</p>
<ol type="1">
<li>对每一条边 <span class="math inline">\(e \in E\)</span>
，最开始初始化 <span class="math inline">\(f(e)=0\)</span>
，即每一条边上的流量为0</li>
<li>找到从起点 <span class="math inline">\(s\)</span> 到终点 <span
class="math inline">\(t\)</span> 的路径 <span
class="math inline">\(P\)</span> ，满足 <span
class="math inline">\(f(e)&lt;c(e)\)</span>
，即找到从起点到终点流量小于容量的路径</li>
<li>将 <span class="math inline">\(P\)</span> 作为增广路径进行增广</li>
<li>一直重复知道算法终止</li>
</ol></li>
<li><p>贪心算法不能得到最优解</p>
<ol type="1">
<li>贪心算法无法撤销那些“坏”的操作</li>
</ol></li>
<li><p>残量网络</p>
<ol type="1">
<li><p>原来的边 <span class="math inline">\(e\ = (u,v )\in
E\)</span></p>
<ol type="1">
<li>边上的流为 <span class="math inline">\(f(e)\)</span></li>
<li>边上的容量为 <span class="math inline">\(c(e)\)</span></li>
</ol></li>
<li><p>反向边 <span class="math inline">\(e^{reverse}=(v,u)\)</span></p>
<ol type="1">
<li>反向边就是对流的撤销操作</li>
</ol></li>
<li><p>残留容量 <span class="math display">\[
c_f(e)=
\begin{cases}
c(e)-f(e) &amp; if\ e \in E\\
f(e) &amp; if\ e^{reverse}\in E
\end{cases}
\]</span></p></li>
<li><p>残量网络 <span
class="math inline">\(G_f=(V,E_f,s,t,c_f)\)</span></p>
<ol type="1">
<li><span class="math inline">\(E_f=\lbrace e:f(e)&lt;c(e)\rbrace \cup
\lbrace e^{reverse}:f(e)&gt;0\rbrace\)</span>
，即残量网络的边集是由流量小于容量的边以及那些有流量的反向边的并集。</li>
<li>关键性质：<span class="math inline">\(f&#39;\)</span> 是一个在 <span
class="math inline">\(G_f\)</span> 中的流，当且仅当 <span
class="math inline">\(f+f&#39;\)</span> 是 <span
class="math inline">\(G\)</span> 上的流。</li>
</ol></li>
</ol></li>
<li><p>在残量网络中运行贪心算法即为Ford–Fulkerson算法</p>
<ol type="1">
<li><p>增广路径是在 <span class="math inline">\(G_f\)</span> 上的一条由
<span class="math inline">\(s\rightarrow t\)</span> 的简单路径</p></li>
<li><p>瓶颈容量是增广路径 <span class="math inline">\(P\)</span>
上的所有边的最小残留容量。</p></li>
<li><p>关键性质：令 <span class="math inline">\(f\)</span>
为一个流，<span class="math inline">\(P\)</span> 为 <span
class="math inline">\(G_f\)</span> 上的一条增广路径。在调用
$f'AUGMENT(f,c,P) $ 的算法之后，结果 <span
class="math inline">\(f&#39;\)</span> 是一个流，同时，<span
class="math inline">\(val(f&#39;)=val(f)+bottleneck(G_f,P)\)</span></p></li>
<li><p>增加增广路径的伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AUGMENT(f,c,P)</span><br><span class="line"></span><br><span class="line">δ ← 增广路径P的瓶颈容量</span><br><span class="line">FOREACH P中的边e</span><br><span class="line">	IF (e ∈ E) </span><br><span class="line">		f(e) ← f(e) + δ</span><br><span class="line">	ELSE </span><br><span class="line">		f(e_r) ← f(e_r) - δ</span><br><span class="line">RETURN f</span><br></pre></td></tr></table></figure>
<p>注：伪代码中的 e_r 即为 <span
class="math inline">\(e^{reverse}\)</span></p></li>
<li><p>Ford–Fulkerson算法</p>
<ol type="1">
<li>对每一条边 <span class="math inline">\(e \in E\)</span>
，最开始初始化 <span class="math inline">\(f(e)=0\)</span>
，即每一条边上的流量为0</li>
<li>在 <span class="math inline">\(G_f\)</span> 中找到从起点 <span
class="math inline">\(s\)</span> 到终点 <span
class="math inline">\(t\)</span> 的路径 <span
class="math inline">\(P\)</span> ，满足 <span
class="math inline">\(f(e)&lt;c(e)\)</span>
，即找到从起点到终点流量小于容量的路径</li>
<li>将 <span class="math inline">\(P\)</span> 作为增广路径进行增广</li>
<li>一直重复直到算法终止</li>
</ol></li>
<li><p>Ford–Fulkerson算法伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Ford–Fulkerson(G)</span><br><span class="line"></span><br><span class="line">FOREACH e∈E</span><br><span class="line">	f(e) ← 0</span><br><span class="line">Gf ← G的残量网络</span><br><span class="line">WHILE (在Gf中存在一条s→t的路径P)</span><br><span class="line">	f ← AUGMENT(f,c,P)</span><br><span class="line">	更新Gf</span><br><span class="line">RETURN f</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>正确性证明</p></li>
<li><p>运行时间</p>
<ol type="1">
<li>假设每一条边上的容量 <span class="math inline">\(c(e)\)</span>
是一个介于 <span class="math inline">\(1\)</span> 和 <span
class="math inline">\(C\)</span> 之间的整数</li>
<li>经过Ford–Fulkerson算法，每一条边上的流值 <span
class="math inline">\(f(e)\)</span> 和残留容量 <span
class="math inline">\(c_f(e)\)</span> 是一个整数</li>
<li>Ford–Fulkerson算法在最多 $ n C$ 条增广路径后停止，且 <span
class="math inline">\(val(f^*) \le n C\)</span> ，其中 <span
class="math inline">\(f^*\)</span> 为最大流</li>
<li>Ford–Fulkerson算法的运行时间为 <span
class="math inline">\(O(mnC)\)</span>
，因为使用BFS或DFS寻找增广路径使用<span
class="math inline">\(O(m)\)</span> 的时间。</li>
<li>整数定理：存在一个整数的最大流 <span
class="math inline">\(f^*\)</span></li>
</ol></li>
</ol>
<h2 id="最大流最小割定理">最大流最小割定理</h2>
<ol type="1">
<li><p>流值引理</p>
<ol type="1">
<li>令 <span class="math inline">\(f\)</span> 为任意流，<span
class="math inline">\((A,B)\)</span> 为任意割集，那么，流 <span
class="math inline">\(f\)</span> 的值 <span
class="math inline">\(val(f)\)</span> 等于经过割集 <span
class="math inline">\((A,B)\)</span> 的流</li>
</ol></li>
<li><p>流和割构成弱对偶关系</p>
<ol type="1">
<li><p>令 <span class="math inline">\(f\)</span> 为任意流，<span
class="math inline">\((A,B)\)</span> 为任意割集，那么，流 <span
class="math inline">\(f\)</span> 的值 <span
class="math inline">\(val(f)\)</span> 小于割集 <span
class="math inline">\((A,B)\)</span> 的容量。</p></li>
<li><p>证明： <span class="math display">\[
\begin{align}
val(f) &amp;=\sum_{\text{e out of A}}{f(e)} - \sum_{\text{e in to
A}}{f(e)}
\\ &amp;\le \sum_{\text{e out of A}}{f(e)}
\\ &amp;\le \sum_{\text{e out of A}}{c(e)}
\\ &amp;= cap(A,B)
\end{align}
\]</span></p></li>
</ol></li>
<li><p>最优性条件</p>
<ol type="1">
<li>令 <span class="math inline">\(f\)</span> 为任意流，<span
class="math inline">\((A,B)\)</span> 为任意割集，那么，当流 <span
class="math inline">\(f\)</span> 的值 <span
class="math inline">\(val(f)\)</span> 等于割集 <span
class="math inline">\((A,B)\)</span> 的容量时，流 <span
class="math inline">\(f\)</span> 为最大流，割集 <span
class="math inline">\((A,B)\)</span> 为最小割。</li>
</ol></li>
<li><p>最大流和最小割定理</p>
<ol type="1">
<li><p>最大流的流值等于最小割的容量</p>
<ol type="1">
<li>我们通过一下三个条件来进行命题的证明。
<ol type="1">
<li>存在一个割集 (A,B)，<span
class="math inline">\(cap(A,B)=val(f)\)</span></li>
<li><span class="math inline">\(f\)</span> 是一个最大流</li>
<li><span class="math inline">\(f\)</span> 没有增广路径</li>
</ol></li>
</ol></li>
</ol></li>
</ol>
<h2 id="变尺度算法">变尺度算法</h2>
<ol type="1">
<li><p>如何选择增广路径</p></li>
<li><p>变尺度算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAPACITY-SCALING(G)</span><br><span class="line"></span><br><span class="line">FOREACH e∈E</span><br><span class="line">	f(e) ← 0</span><br><span class="line">Δ ← 2的最大幂次（&lt;= C)</span><br><span class="line">WHILE (Δ &gt;= 1)</span><br><span class="line">	Gf(Δ) ← G关于流f的Δ-残量网络</span><br><span class="line">	WHILE(在Gf(Δ)中存在一条s→t的路径P)</span><br><span class="line">		f ← AUGMENT(f,c,P)</span><br><span class="line">		更新Gf(Δ)</span><br><span class="line">	Δ ← Δ/2</span><br><span class="line">RETURN f</span><br></pre></td></tr></table></figure></li>
<li><p>正确性证明</p>
<ol type="1">
<li>假设，所有边的容量都是介于1到C的整数</li>
<li>变尺度参数 <span class="math inline">\(\Delta\)</span>
是一个2的幂次</li>
<li><span class="math inline">\(\Delta=1\)</span> 时，没有增广路径</li>
</ol></li>
<li><p>运行时间</p>
<ol type="1">
<li><p>引理1：算法最多循环 <span class="math inline">\(1+\left \lfloor
logC\right \rfloor\)</span> 次</p>
<ol type="1">
<li>最开始初始化时，<span class="math inline">\(C/2 &lt; \Delta \le
C\)</span> ，而 <span class="math inline">\(\Delta\)</span>
在每次循环中会除以 <span class="math inline">\(2\)</span> .</li>
</ol></li>
<li><p>引理2：令 <span class="math inline">\(f\)</span> 为一个 <span
class="math inline">\(\Delta\)</span>-变尺度阶段后的流，则最大流值不超过
<span class="math inline">\(val(f)+m\Delta\)</span></p>
<ol type="1">
<li><p><span class="math display">\[
\begin{align}
val(f) &amp;=\sum_{\text{e out of A}}{f(e)} - \sum_{\text{e in to
A}}{f(e)}
\\&amp;\ge\sum_{\text{e out of A}}{(c(e)-\Delta)} - \sum_{\text{e in to
A}}{\Delta}
\\&amp;\ge \sum_{\text{e out of A}}c(e) - \sum_{\text{e out of
A}}{\Delta} -\sum_{\text{e in to A}}{\Delta}
\\&amp;\ge cap(A,B)-m\Delta
\end{align}
\]</span></p></li>
<li><p>流出边的流量一定<span class="math inline">\(\le \Delta\)</span>
，流入边的容量一定 <span class="math inline">\(\le
\Delta\)</span></p></li>
</ol></li>
<li><p>引理3：每个阶段最多进行 <span class="math inline">\(2m\)</span>
次增广</p>
<ol type="1">
<li>令 <span class="math inline">\(f\)</span> 为一个 <span
class="math inline">\(\Delta\)</span>-变尺度阶段<strong>前</strong>的流</li>
<li>由引理2可知，最大流值不超过 <span class="math inline">\(val(f)+m
(2\Delta)\)</span></li>
<li>而在<span
class="math inline">\(\Delta\)</span>阶段，每次增广至少<span
class="math inline">\(\Delta\)</span>的流量。</li>
</ol></li>
<li><p>定理：变容算法运行时间为 <span
class="math inline">\(O(m^2logC)\)</span></p></li>
</ol></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rebecca"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Rebecca</p>
  <div class="site-description" itemprop="description">弱小和无知不是生存的障碍，傲慢才是。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-03 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rebecca</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
